# Добавление медиа-контента

[Главная](https://webref.ru/) / [Вёрстка](https://webref.ru/layout) / [Уроки по HTML и CSS](https://webref.ru/layout/learn-html-css) / Добавление медиа-контента /

[Комментариев: 23](https://webref.ru/layout/learn-html-css/adding-media#disqus_thread)

Мы просматриваем Интернет в поисках интересной и познавательной информации, которую обычно находим в виде простого текста. Для его сопровождения HTML предлагает способы внедрить мультимедиа в виде изображений, аудио и видео, а также включить контент с другой веб-страницы в виде встроенного фрейма.

Возможность включать изображения, звук, видео и встроенные фреймы на сайты существует уже некоторое время. Браузеры поддерживают изображения и встроенные фреймы в целом очень хорошо. И хотя добавлять звук и видео на сайт можно уже много лет, этот процесс был довольно громоздким. К счастью, он совершенствуется и стал гораздо проще с прямой поддержкой из HTML.

Сегодня мы можем свободно использовать изображения, аудио, видео и встроенные фреймы, зная что они поддерживаются всеми основными браузерами.

## Добавление изображений

Чтобы добавить изображения на страницу мы используем строчный элемент <img>. Элемент <img> относится к самостоятельным или к пустым элементам; это означает, что он не содержит какого-либо контента и существует в виде единственного тега. Для работы <img> должен быть включен атрибут src со значением, указывающим исходник изображения. Значение атрибута src это URL, обычно относительно сервера, на котором размещён сайт.

Наряду с атрибутом src должен быть применён атрибут alt (альтернативный текст), который описывает содержимое изображения. Значение атрибута alt собирают поисковые системы и вспомогательные технологии, это помогает им донести назначение изображения. Альтернативный текст будет отображаться вместо изображения, если по какой-то причине изображение не доступно.

```
<img src="dog.jpg" alt="Чёрно-бело-коричневая собака с надетым на неё платком">
```

### Демонстрация добавления изображения

![Альтернативный текст показан на месте отсутствующего изображения](https://webref.ru/assets/images/learn-html-css/alternate-text.png)

Рис. 9.01. Альтернативный текст показан на месте отсутствующего изображения

### Поддерживаемые форматы изображений

Изображения поступают в разных форматах файлов и каждый браузер может поддерживать (или не поддерживать) различные форматы. По большому счёту, наиболее типовые поддерживаемые форматы изображений в Интернете — это gif, jpg и png. Из них наиболее широко используемыми сегодня форматами являются jpg и png. Формат jpg обеспечивает качество изображения с высоким количеством цветов, сохраняя скромный размер файла, идеально подходящего для быстрой загрузки. Формате png отлично подходит для изображений с прозрачностью или малым числом цветов. Мы обычно видим что изображения в jpg используются для фотографий, а изображения в png — для иконок или фоновых узоров.

### Размеры изображений

Важно определить размер изображения, чтобы сказать браузеру, насколько большой должна быть картинка до загрузки страницы. Таким образом браузер может зарезервировать место для изображения и отображать страницы быстрее. Есть несколько разных способов задать размер изображений, которые хорошо работают на странице. Одним из способов является использование атрибутов width и height непосредственно в теге <img> в HTML.

Кроме того, для указания размеров изображения могут быть использованы свойства width и height в CSS. Когда одновременно применяются свойства CSS и атрибуты HTML, то свойства CSS будут иметь приоритет над атрибутами HTML.

Указание только ширины или высоты настроит другой размер автоматически, чтобы сохранить пропорции изображения. В качестве примера, если мы хотим, чтобы изображение было 200 пикселей в высоту, но ширина нас не особо беспокоит, то мы можем установить height как 200 пикселей, а ширина изображения подстроится соответственно. Одновременная установка width и height также будет работать, однако это может нарушить пропорции изображения, в результате чего появятся искажения.

```
img {
  height: 200px;
  width: 200px;
}
```

### Демонстрация размеров изображения

Хотя с помощью атрибутов width и height непосредственно в HTML сохраняется некоторое смысловое значение в виде исходного размера изображения, может быть трудно управлять множеством изображений одинакового размера. В таком случае обычной практикой будет использование CSS для изменения размеров изображений.

### Позиционирование изображений

Мы можем использовать ряд разных подходов для позиционирования изображений на веб-странице. По умолчанию изображения позиционируются как строчно-блочные элементы, однако их положение может быть изменено с помощью CSS, в частности, float, display и свойств блочной модели, включая padding, border и margin.

#### Строчное позиционирование изображений

Элемент <img> является по умолчанию строчно-блочным. Добавление изображения на страницу без каких-либо стилей будет позиционировать его на той же строке, что и содержимое вокруг изображения. Кроме того, изменится высота строки, в которой появляется изображение, чтобы соответствовать высоте изображения и это может создать большие вертикальные зазоры в строке.

```
<p>Гэтсби — чёрно-бело-коричневая дворняга, которая любит вой пожарных машин и когда ему чешут пузо.
<img src="dog.jpg" alt="Чёрно-бело-коричневая собака с надетым на неё платком"> 
Несмотря на то, что он большую часть времени спит, он очень быстро гоняется за любыми птицами, которых видит во сне.</p>
```

### Демонстрация строчного изображения

Оставлять изображения позиционированными по умолчанию приходится редко. Чаще изображения отображаются как блочные или обтекаемые по одной стороне элементы.

#### Блочное позиционирование изображений

Добавив свойство display к изображению и установив его значение как block мы заставим изображение быть блочным элементом. Это отображает изображение на отдельной строке, что позволяет окружающему содержимому располагаться выше и ниже изображения.

```
img {
  display: block;
}
```

### Демонстрация блочного изображения

#### Позиционирование изображений слева или справа

Иногда вывод изображения как строчного, блочного или, возможно, даже строчно-блочного элемента не является идеальным. Мы можем сделать так, чтобы изображение появилось на левой или правой стороне содержащего его элемента, в то время как другое содержимое обтекало вокруг изображения при необходимости. Чтобы сделать это, мы используем свойство float со значением left или right.

Возвращаясь обратно к уроку 5, «[Позиционирование содержимого](https://webref.ru/layout/learn-html-css/positioning-content)», напомним, что свойство float первоначально предназначалось для размещения изображений слева или справа в содержащем их элементе. Теперь мы используем его для этой изначальной цели.

Обтекание изображения это начало, всё остальное содержимое будет выравниваться непосредственно напротив. Для обеспечения пространства вокруг изображения мы воспользуемся свойством margin. Дополнительно мы можем применить свойства padding, border и background чтобы создать рамку вокруг изображения по желанию.

```
img {
  background: #eaeaed;
  border: 1px solid #9799a7;
  float: right;
  margin: 8px 0 0 20px;
  padding: 4px;
}
```

### Демонстрация обтекаемого изображения

### Когда использовать изображения вместо фоновой картинки

Есть два основных способа добавления изображения на веб-страницу. Описанный здесь способ — это использование элемента <img> в HTML. Другой способ заключается в применении свойства background или background-image в CSS и назначении фонового изображения для элемента. Оба варианта выполняют свою работу, но у каждого есть свои конкретные области применения.

Элемент <img> в HTML является предпочтительным вариантом, когда изображение должно сохранять смысловое значение и имеет отношение к содержанию страницы.

Свойство background или background-image в CSS является предпочтительным вариантом, когда изображение используется как часть дизайна или интерфейса на странице. Как таковое, оно напрямую не связано с содержанием страницы.

Элемент <img> является довольно популярным и когда был первоначально добавлен в спецификацию HTML, то навсегда изменил путь создания сайтов.

## На практике

Теперь, когда мы знаем как добавить и позиционировать изображения на странице, давайте взглянем на наш сайт Styles Conference и посмотрим, куда мы можем вставить несколько изображений.

1. Начнём с добавления нескольких изображений на нашу главную страницу. В частности, мы добавим изображение в каждый раздел с тизером, продвигающих некоторые наши страницы.

   Прежде, чем мы перепрыгнем к коду, давайте создадим новую папку с названием images в нашей папке assets. Затем, в папке images создадим другую папку с названием home специально для изображений нашей главной страницы. В папку home мы добавим три изображения: speakers.jpg, schedule.jpg и venue.jpg (для справки, эти изображения можно скачать из zip-файла).

   Далее, в нашем файле index.html, каждый раздел с тизером содержит элемент <a>, который одновременно обёртывает элементы <h3> и <h5>. Переместим элемент <h5> выше элемента <a> и заменим его элементом <img>. Значение атрибута src для каждого элемента <img> будет соответствовать структуре папок и имени созданного файла, а значение атрибута alt будет описывать содержание каждого изображения.

   HTML для нашего первого тизера со спикерами будет выглядеть следующим образом:

   ```
   <section class="teaser col-1-3">
     <h5>Спикеры</h5>
     <a href="speakers.html">
       <img src="assets/images/home/speakers.jpg" alt="Профессиональные спикеры">
       <h3>Спикеры мирового класса</h3>
     </a>
     <p>К нам приедут более двадцати фантастических спикеров со всего мира, чтобы поделиться своими историями.</p>
   </section>
   ```

   Продолжим этот шаблон также для тизеров расписания и места проведения.

2. Теперь, когда мы добавили несколько изображений на нашу страницу, нам нужно немного очистить их стили и убедиться, что они правильно вписываются в макет нашей страницы.

   Так как изображения по умолчанию являются строчно-блочными элементами, давайте изменим изображения в разделе с тизерами на блочные элементы. Также установим их максимальную ширину как 100%, чтобы гарантировать, что они не превышают ширину соответствующих им колонок. Изменение значения этой ширины важно, поскольку она позволяет нашим изображения подстраиваться под ширину колонок по мере необходимости.

   Наконец, давайте немного скруглим углы изображений и применим к ним нижний margin 22 пикселя, обеспечивая небольшую свободу.

   После того, как мы добавим эти новые стили к нашим существующим стилям для главной страницы (с помощью класса teaser в качестве отборочного селектора для элементов <img>), наш CSS будет выглядеть следующим образом:

   ```
   .teaser img {
     border-radius: 5px;
     display: block;
     margin-bottom: 22px;
     max-width: 100%
   }
   ```

3. Затем добавим изображения всех спикеров на странице Спикеры. Мы начнём с создания папки speakers в нашей папке images и поместим в неё изображения всех выступающих.

   В файле speakers.html добавим элемент <img> внутрь каждого элемента <aside> с информацией о спикере. Разместим каждый элемент <img> внутри элемента <div> со значением speaker-info у атрибута class, чуть выше элемента <ul>.

   Значение атрибута src каждого изображения будет соответствовать папке speakers, которую мы создали и имени спикера; значением атрибута alt будет имя спикера.

   Элемент <aside> для меня как спикера будет выглядеть следующим образом:

   ```
   <aside class="col-1-3">
     <div class="speaker-info">

       <img src="assets/images/speakers/shay-howe.jpg" alt="Шэй Хоу">
     
       <ul>
         <li><a href="https://twitter.com/shayhowe">@shayhowe</a></li>
         <li><a href="http://learn.shayhowe.com/">learn.shayhowe.com</a></li>
       </ul>

     </div>
   </aside>
   ```

   Этот же шаблон добавления изображения следует применить ко всем другим спикерам.

4. Как мы делали с изображениями на нашей главной странице, так же мы хотим применить некоторые стили для изображений на странице Спикеры.

   Начнём с применения свойства border-radius со значением 50%, превращая наши изображения в круги. Отсюда установим фиксированную высоту 130 пикселей для каждой картинки и зададим вертикальное выравнивание по верху строки, в которой они находятся.

   После этого применим к изображениям вертикальные отступы. Используя отрицательный margin сверху в 66 пикселей мы вытянем немного изображения из элемента <aside> и выровняем по центру верхней границы элемента <div> с классом speaker-info. Далее, применение margin как 22 пикселя к нижней части изображения обеспечивает пространство между изображением и элементом <ul> ниже него.

   После того, как мы добавим эти новые стили к нашим существующим стилям страницы Спикеры (с помощью класса speaker-info в качестве отборочного селектора для элементов <img>), наш CSS будет выглядеть следующим образом:

   ```
   .speaker-info img {
     border-radius: 50%;
     height: 130px;
     margin: -66px 0 22px 0;
     vertical-align: top;
   }
   ```

5. Поскольку мы используем агрессивный негативный margin для элемента <img> внутри элемента <div> с классом speaker-info, мы должны убрать padding сверху у этого элемента <div>.

   Ранее мы использовали свойство padding со значением 22px 0, таким образом указали 22 пикселя paddingсверху и снизу и 0 пикселей padding слева и справа у элемента <div>. Давайте заменим это свойство и значение на свойство padding-bottom, так как нам нужно определить только этот padding и используем значение 22 пикселя.

   Новый набор правил для класса speaker-info выглядит следующим образом:

   ```
   .speaker-info {
     border: 1px solid #dfe2e5;
     border-radius: 5px;
     margin-top: 88px;
     padding-bottom: 22px;
     text-align: center;
   }
   ```

Теперь главная страница и страница Спикеры выглядят весьма круто.

![Главная страница Styles Conference после добавления изображений в каждый раздел с тизером](https://webref.ru/assets/images/learn-html-css/practice-9-02.png)

Рис. 9.02. Главная страница Styles Conference после добавления изображений в каждый раздел с тизером

![Страница Спикеры после добавления изображения для каждого спикера](https://webref.ru/assets/images/learn-html-css/practice-9-03.png)

Рис. 9.03. Страница Спикеры после добавления изображения для каждого спикера

## Добавление аудио

HTML5 предлагает быстрый и простой способ добавить [аудиофайлы](https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Using_HTML5_audio_and_video) на сайт через [элемент](https://webref.ru/html/audio) <audio>. Как и элемент <img>, элемент <audio> принимает URL исходника, указанного в атрибуте src. При этом, в отличие от элемента <img> элемент <audio> требует открывающий и закрывающий теги, которые мы обсудим в ближайшее время.

```
<audio src="jazz.ogg"></audio>
```

### Атрибуты <audio>

Несколько других атрибутов могут сопровождать атрибут src для элемента <audio>, наиболее популярные это autoplay, controls, loop и preload.

Атрибуты autoplay, controls и loop — логические атрибуты и не требуют наличия значения. Вместо этого, когда каждый присутствует в элементе <audio>, значение атрибута будет установлено истинным и элемент <audio>будет вести себя соответственно.

По умолчанию, элемент <audio> не отображается на странице. Если присутствует логический атрибут autoplay, на странице ничего не появится, но аудиофайл начнёт воспроизводиться автоматически после загрузки.

```
<audio src="jazz.ogg" autoplay></audio>
```

Для отображения элемента <audio> на странице необходим логический атрибут controls. Когда он применяется к элементу <audio> браузер покажет элементы управления по умолчанию, включая воспроизведение, паузу, поиск и регулировку громкости.

```
<audio src="jazz.ogg" controls></audio>
```

### Демонстрация добавления аудио

При наличии логического атрибута loop для элемента <audio> аудиофайл будет повторяться постоянно, с начала и до конца.

Наконец, атрибут preload для элемента <audio> помогает определить, какая информация об аудиофайле, если она есть, должна быть загружена до воспроизведения клипа. Он принимает три значения: none, auto и metadata. Значение none не загружает никакой информации об аудиофайле, в то время как значение auto загрузит всю информацию об аудиофайле. Значение metadata располагается между значениями none и auto и загрузит все доступные сведения об аудиофайле, например, длину клипа, но не всю информацию.

Если атрибут preload не представлен в элементе <audio>, вся информация об аудиофайле будет загружена, словно значение было установлено как auto. По этой причине использование атрибута preload со значением metadata или none — хорошая идея, когда аудиофайл не является необходимым для страницы. Это поможет не загружать канал и позволит странице загружаться быстрее.

### Альтернатива аудио и несколько источников

В настоящее время разные браузеры поддерживают различные форматы аудиофайлов, тремя наиболее популярными из которых являются ogg, mp3 и wav. Для лучшей поддержки браузерами нам нужно использовать несколько аудиофайлов, которые будут включены внутри открывающего и закрывающего тегов элемента <audio>.

Для начала мы удалим атрибут src из элемента <audio>. Вместо этого мы воспользуемся элементом <source> с атрибутом src, вложенный в элемент <audio>, чтобы определить новый исходник.

Используя элемент <source> и атрибут src для каждого формата файла, мы можем перечислить один аудиофайл за другим. Мы будем использовать атрибут type, который поможет браузеру быстро определить, какие типы аудио доступны. Когда браузер распознает формат аудиофайла, он загрузит файл и проигнорирует остальные.

Поскольку элемент <audio> был представлен в HTML5, некоторые браузеры его не поддерживают. В этом случае мы можем предложить ссылку для скачивания аудиофайла после любого элемента <source> внутри <audio>.

```
<audio controls>
  <source src="jazz.ogg" type="audio/ogg">
  <source src="jazz.mp3" type="audio/mp3">
  <source src="jazz.wav" type="audio/wav">
  Пожалуйста, <a href="jazz.mp3" download>скачайте</a> аудиофайл.
</audio>
```

Рассмотрим предыдущий код. Элемент <audio> включает логический атрибут controls, что гарантирует отображение аудиоплеера в браузерах, которые поддерживают этот элемент. <audio> не включает атрибут src, а вместо этого содержит три разных элемента <source>. Каждый элемент <source> включает в себя атрибут srcуказывающий на разный формат аудиофайла и атрибут type, который определяет формат аудиофайла. Последняя строка дана в качестве резерва — если браузер не распознает ни один из форматов аудиофайлов, будет показана ссылка на скачивание.

В дополнение к элементу <audio>, HTML5 также представил элемент <video>, у которого есть довольно много сходства с <audio>.

## Добавление видео

Добавление [видео в HTML5](http://dev.opera.com/articles/introduction-html5-video/) очень похоже на добавление аудио. Мы используем элемент <video> на месте элемента <audio>. Все те же атрибуты (src, autoplay, controls, loop и preload) и альтернативы применимы и здесь.

Для элемента <audio> характерно, что если логический атрибут controls не указан, то аудиоклип не отображается. Для видео, если атрибут controls не указан, то видео будет показано. Однако, его довольно трудно посмотреть, если логический атрибут autoplay также не применяется. В целом, хорошей практикой будет включить атрибут controls, если нет серьёзной причины не позволять пользователям запускать, останавливать или повторять видео.

Поскольку видео занимает место на странице, будет полезно определить его размеры, которые чаще всего делаются через свойства width и height в CSS. Это гарантирует, что видео не окажется слишком большим и останется в пределах макета страницы. Кроме того, задание размера как и с изображениями помогает браузеру отображать видео быстрее и позволяет выделить надлежащее место, необходимое для показа видео.

```
<video src="earth.ogv" controls></video>
```

### Настройка управления аудио и видео

По умолчанию, управление в элементах <audio> и <video> определяются каждым браузером самостоятельно. В зависимости от дизайна сайта, может потребоваться больше власти над внешним видом медиаплеера. В этом случае плеер может быть модифицирован, но для работы потребуется немного JavaScript.

Кроме того, если модифицированный плеер использует элемент <img> в качестве управления, значение атрибута alt должно явно утверждать, что изображение предназначено для управления и требуется необходимое взаимодействие для работы.

### Атрибут poster

Для элемента <video> доступен дополнительный атрибут poster. Этот атрибут позволяет задать изображение в виде URL, которое будет показано до воспроизведения видео. В приведённом ниже примере скриншот из видео используется в качестве постера для видео Земли.

```
<video src="earth.ogv" controls poster="earth-video-screenshot.jpg"></video>
```

### Альтернатива видео

Как и с элементом <audio>, для видео также необходим альтернативный вариант. Аналогичный формат разметки, с несколькими элементами <source> для каждого типа файла и обычный текст как альтернатива, также относится к элементу <video>.

```
<video controls>
  <source src="earth.ogv" type="video/ogg">
  <source src="earth.mp4" type="video/mp4">
  Пожалуйста, <a href="earth.mp4" download>скачайте</a> это видео.
</video>
```

Дополнительным запасным вариантом, который может быть использован вместо обычного текста, является встроенное видео [YouTube](https://www.youtube.com/) или [Vimeo](https://vimeo.com/). Эти сайты видеохостинга позволяют загрузить наши видео, предоставляют стандартный видеоплеер и возможность внедрить видео на страницу с помощью встроенного фрейма.

### Форматы аудио и видеофайлов в HTML5

Поддержка браузеров для элементов <audio> и <video> меняется, как и форматы файлов, необходимых для этих элементов. У каждого браузера есть свои собственные предпочтительные форматы аудио и видеофайлов.

Существует несколько инструментов, которые помогают преобразовать аудио или видеофайл в другие форматы и быстрый поиск даёт изобилие вариантов.

## Добавление встроенных фреймов

Ещё один способ добавления содержимого на страницу — это внедрить другую HTML-страницу в текущую. Это делается с помощью встроенного фрейма или элемента <iframe>. Данный элемент принимает URL другой HTML-страницы в значении атрибута src — это вызывает содержимое из внедрённой HTML-страницы для отображения на текущей странице. Значение атрибута src может быть URL относительно страницы, где появляется элемент <iframe> или абсолютным адресом для исключительно внешней страницы.

Многие страницы используют элемент <iframe> для внедрения медиа-контента на страницу с внешнего сайта, вроде Google Maps, YouTube и др.

```
<iframe src="https://www.google.com/maps/embed?..."></iframe>
```

### Демонстрация добавления встроенного фрейма

Элемент <iframe> содержит несколько стилей по умолчанию, в том числе border, width и height. Эти стили можно регулировать с помощью атрибутов в HTML frameborder, width и height или с помощью CSS-свойств border, width и height.

### Атрибут seamless

Страницы, на которые ссылается атрибут src элемента <iframe> играют по своим правилам — так, они не наследуют любые стили или поведение со страницы, на которую указывают. Любые стили применяемые к странице с элементом <iframe> не наследуются страницей внутри элемента <iframe>. Кроме того, ссылки внутри страницы в элементе <iframe> откроются внутри фрейма, оставляя страницу, которая содержит элемент <iframe>, без изменений.

У нас будет время, когда мы захотим изменить подобное поведение и логический атрибут seamless позволит нам это сделать. Когда атрибут seamless присутствует в элементе <iframe> это разрешает стилям для страницы с элементом <iframe> наследоваться странице внутри элемента <iframe>. Кроме того, атрибут seamless позволяет ссылкам, нажатым на странице внутри <iframe>, открываться в том же окне, что и исходная страницы, содержащая элемент <iframe>.

```
<iframe src="contact.html" seamless></iframe>
```

Атрибут seamless является новым атрибутом представленным в HTML5. Хотя поддержка браузеров для этого атрибута растёт, он не будет работать в старых браузерах. Рекомендуем проверить атрибут seamless перед его использованием.

## На практике

Встроенные фреймы предлагают отличный способ добавления динамического содержимого на страницу. Позволим им выстрелить и обновим нашу страницу «Место проведения» некоторыми картами.

1. Перед добавлением любых карт или встроенных фреймов давайте сначала подготовим нашу страницу для сетки из двух колонок. Ниже раздела со вступлением мы добавим элемент <section> с классом row, чтобы определить новый раздел страницы и включить некоторые общие стили, такие как белый фон и вертикальный padding.

   Непосредственно внутри этого элемента <section> добавим элемент <div> с классом grid. Класс gridвыравнивает наш контент по центру страницы и готовится сопровождать колонки 1/3 и 2/3.

   Пока главный раздел нашего файла venue.html выглядит следующим образом:

   ```
   <section class="row">
     <div class="grid">
     ...
     </div>
   </section>
   ```

2. В элементе <div> с классом grid у нас будет два новых раздела: один для места конференции, а второй для гостиницы. Добавим два новых элемента <section> и дадим каждому из них уникальный класс, который соответствует его содержанию. Мы будем использовать эти классы для добавления margin снизу каждого раздела.

   Наш HTML должен выглядеть так:

   ```
   <section class="row">
     <div class="grid">

       <section class="venue-theatre">
         ...
       </section>

       <section class="venue-hotel">
         ...
       </section>

     </div>
   </section>
   ```

3. Теперь у нас есть несколько классов для работы, давайте создадим новый раздел в нашем файле main.css для стилей страницы «Место проведения». Мы добавим нижний margin 66 пикселей к элементу <section> с классом venue-theatre, чтобы вставить некоторое пространство между ним и элементом <section> ниже.

   Затем мы добавим 22-пиксельный margin внизу элемента <section> с классом venue-hotel, чтобы обеспечить некоторое пространство между ним и элементом <footer> ниже.

   Новый раздел в файле main.css выглядит следующим образом:

   ```
   /*
     ========================================
     Место проведения
     ========================================
   */

   .venue-theatre {
     margin-bottom: 66px;
   }
   .venue-hotel {
     margin-bottom: 22px;
   }
   ```

   У элемента <section> с классом venue-hotel нижний margin меньше, чем у элемента <section> с классом venue-theatre, потому что он соседствует с нижним padding от элемента <section> с классом row. Совместное добавление margin и padding даст нам то же значение, что и нижний margin для элемента <section> с классом venue-theatre.

4. Теперь пришло время для создания двух колонок в каждом новом элементе <section>. Мы начнём с добавления элемента <div> с классом col-1-3, чтобы установить колонку 1/3. После этого добавим элемент <iframe> с классом col-2-3, чтобы установить колонку 2/3.

   Подразумевая, что колонки, сделанные элементами <div> и <iframe> — это строчно-блочные элементы, мы должны удалить пустое пространство, которое будет отображаться между ними. Для этого откроем комментарий HTML сразу после закрывающего тега <div> и закроем комментарий непосредственно перед открывающим тегом <iframe>.

   В целом, наш HTML для колонок выглядит следующим образом:

   ```
   <section class="row">
     <div class="grid">

       <section class="venue-theatre">
     
         <div class="col-1-3"></div><!--
         --><iframe class="col-2-3"></iframe>
     
       </section>
     
       <section class="venue-hotel">

         <div class="col-1-3"></div><!--
         --><iframe class="col-2-3"></iframe>
     
       </section>

     </div>
   </section>
   ```

5. В каждый из элементов <div> с классом col-1-3 добавим название места внутри элемента <h2>, затем два элемента <p>. В первом элементе <p> включим адрес места проведения, а во втором <р> элемента включим их сайт (со ссылкой) и номер телефона.

   Внутри каждого абзаца используем элемент перевода строки <br>, чтобы разместить разрывы в адресе и между сайтом и номером телефона.

   Для элемента <section> с классом venue-theatre HTML выглядит следующим образом:

   ```
   <section class="venue-theatre">

     <div class="col-1-3">
       <h2>Chicago Theatre</h2>
       <p>175 N State St <br> Chicago, IL 60601</p>
       <p><a href="http://www.thechicagotheatre.com/">thechicagotheatre.com</a> <br> (312) 462-6300</p>
     </div><!--

     --><iframe class="col-2-3"></iframe>
    
   </section>
   ```

   Этот же шаблон показанный здесь для театра следует также применять к гостинице (с использованием, конечно же, соответствующего адреса, веб-сайта и номера телефона).

6. Мы можем поискать эти адреса в [Google Maps](https://www.google.com/maps/). После того, как найдём адрес и создадим персональную карту, у нас есть возможность вставить эту карту на нашу страницу. Следуйте инструкциям на Google Maps о том как внедрить карту и получить HTML для элемента <iframe>.

   Скопируйте HTML — элемент <iframe>, атрибут src и вставьте на нашу страницу, где расположен существующий элемент <iframe>. Мы сделаем это для каждого места, применяя два разных элемента <iframe>.

   При копировании элемента <iframe> из Google Maps мы должны убедиться, что сохраняем атрибут class и значение col-2-3 в нашем существующем <iframe>. Мы также должны быть осторожны, чтобы не повредить комментарий HTML, который закрывается непосредственно перед открывающим тегом <iframe>.

   Глядя прямо на <section> с классом venue-theatre, HTML выглядит следующим образом:

   ```
   <section class="venue-theatre">

     <div class="col-1-3">
       <h2>Chicago Theatre</h2>
       <p>175 N State St <br> Chicago, IL 60601</p>
       <p><a href="http://www.thechicagotheatre.com/">thechicagotheatre.com</a> <br> (312) 462-6300</p>
     </div><!--

     --><iframe class="col-2-3" src="https://www.google.com/maps/embed?pb=!1m5!3m3!1m2!1s0x880e2ca55810a493%3A0x4700ddf60fcbfad6!2schicago+theatre!5e0!3m2!1sen!2sus!4v1388701393606"></iframe>
    
   </section>
   ```

7. Наконец, мы хотим убедиться, что оба элемента <iframe>, которые ссылаются на Google Maps, одинаковой высоты. Чтобы сделать это, мы создадим новый класс venue-map и применим его к каждому элементу <iframe>наряду с существующим классом col-2-3.

   HTML для элемента <section> с классом venue-theatre теперь выглядит следующим образом:

   ```
   <section class="venue-theatre">

     <div class="col-1-3">
       <h2>Chicago Theatre</h2>
       <p>175 N State St <br> Chicago, IL 60601</p>
       <p><a href="http://www.thechicagotheatre.com/">thechicagotheatre.com</a> <br> (312) 462-6300</p>
     </div><!--

     --><iframe class="venue-map col-2-3" src="https://www.google.com/maps/embed?pb=!1m5!3m3!1m2!1s0x880e2ca55810a493%3A0x4700ddf60fcbfad6!2schicago+theatre!5e0!3m2!1sen!2sus!4v1388701393606"></iframe>
    
   </section>
   ```

   После того, как класс venue-map применяется к каждому элементу <iframe>, давайте создадим набор правил для этого класса в нашем файле main.css. Он включает в себя свойство height со значением 264 пикселей.

   Набор правил для класса venue-map выглядит так:

   ```
   .venue-map {
     height: 264px;
   }
   ```

Теперь у нас есть страница с местом проведения, в комплекте с картами для разных мест нашей конференции.

![Наша страница «Место проведения» теперь включает встроенные фреймы](https://webref.ru/assets/images/learn-html-css/practice-9-04.png)

Рис. 9.04. Наша страница «Место проведения» теперь включает встроенные фреймы

### Демонстрация и исходный код

Ниже вы можете просмотреть сайт Styles Conference в его нынешнем состоянии, а также скачать исходный код сайта на данный момент.

[Просмотр сайта Styles Conference](https://webref.ru/example/learn-html-css/adding-media/) или [Скачать исходный код](https://webref.ru/assets/files/adding-media.zip)

## Семантическое определение figure и figcaption

С HTML5 также пришли элементы <figure> и <figcaption>. Эти [элементы](http://html5doctor.com/the-figure-figcaption-elements/) были созданы для семантической разметки самостоятельного содержимого или медиа-контента, обычно с заголовком. До HTML5 это часто делалось с помощью нумерованного списка и хотя такой список работал, разметка была семантически неверной.

### <figure>

Блочный элемент <figure> применяется для идентификации и охватывания независимого содержимого, часто в виде медиа-контента. Он может окружать изображения, аудиоклипы, видео, блоки кода, диаграммы, рисунки или другой самостоятельный медиа-контент. Внутри <figure> одновременно может содержаться более одного независимого содержимого, вроде нескольких изображений и видео. Если элемент <figure> перемещается из основной части страницы в другое место (например, вниз страницы), это не должно нарушать содержимое или удобочитаемость страницы.

```
<figure>
  <img src="dog.jpg" alt="Чёрно-бело-коричневая собака с надетым на неё платком">
</figure>
```

### Демонстрация <figure>

### <figcaption>

Чтобы добавить подпись или пояснение к элементу <figure> применяется элемент <figcaption>. Элемент <figcaption> может появиться вверху, внизу или где-то ещё в элементе <figure>, но только один раз. Во время использования элемент <figcaption> служит заголовком для всего контента внутри элемента <figure>.

Кроме того, <figcaption> может заменить атрибут alt элемента <img>, если содержимое элемента <figcaption>предлагает полезное описание визуального содержания изображения.

```
<figure>
  <img src="dog.jpg">
  <figcaption>Красивая чёрно-бело-коричневая дворняга с надетым на неё платком.</figcaption>
</figure>
```

### Демонстрация <figcaption>

Не всякий тип медиа-контента должен быть включён в элемент <figure> или включать <figcaption>. Только тот, который является независимым и относится к одной группе.

## Резюме

Наряду с текстом, медиа-контент является огромной частью Интернета. Применение изображений, аудио и видео только выросло за последние годы и это, вероятно, не замедлится. Теперь мы знаем как включить эти виды медиа-контента в наши проекты и как мы можем использовать их, чтобы обогатить содержание наших сайтов.

В этом уроке мы рассмотрели следующее:

- лучшие способы добавления на страницу изображений, аудиоклипов, видео и встроенных фреймов;
- разные способы позиционирования изображений в различных ситуациях; как обеспечить альтернативу аудио и видео для старых браузеров;
- типовые атрибуты, доступные для аудиоклипов и видео;
- атрибут seamless, который позволяет нам сделать поведение встроенных фреймов так, будто они являются частью страницы, из которой они вызываются;
- семантический способ разметить независимое содержимое, в том числе медиа-контент.

Мы выходим на финишную прямую в изучении HTML и CSS, осталось только представить несколько компонент. Следующими по списку идут формы.

## Ресурсы и ссылки

- [Using HTML5 audio and video](https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Using_HTML5_audio_and_video) на Mozilla Developer Network
- [Audio HTML5 Element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio) на Mozilla Developer Network
- [Introduction to HTML5 Video](http://dev.opera.com/articles/introduction-html5-video/) на Dev.Opera
- [The figure & figcaption elements](http://html5doctor.com/the-figure-figcaption-elements/) на HTML5 Doctor









# Видео на сайте

[Главная](https://webref.ru/) / [Вёрстка](https://webref.ru/layout) / [Погружение в HTML5](https://webref.ru/layout/diveintohtml5) / Видео на сайте /

[Комментариев: 10](https://webref.ru/layout/diveintohtml5/video#disqus_thread)

Любой, кто посещал YouTube.com за последние четыре года знает, что можно вставить видео на веб-страницу. До HTML5 не существовало стандартного способа сделать это, фактически, любое видео, что вы видели в Интернете, было добавлено через сторонние плагины вроде QuickTime, RealPlayer или Flash (на YouTube используется именно он). Эти плагины достаточно хорошо интегрированы с браузером, поэтому вы могли даже не знать, что их используете. Но это до тех пор, пока не попытаетесь посмотреть видео на платформе без поддержки плагина.

HTML5 определяет стандартный способ вставки видео на веб-страницу с помощью элемента <video>. Поддержка <video> все ещё развивается и это вежливый способ сказать, что он пока не работает, по крайней мере, работает не везде. Но не отчаиваетесь! Есть альтернативные способы добавления, причём в изобилии.

| IE   | Firefox | Safari | Chrome | Opera | iPhone | Android |
| ---- | ------- | ------ | ------ | ----- | ------ | ------- |
| 9.0+ | 3.5+    | 3.0+   | 3.0+   | 10.5+ | 1.0+   | 2.0+    |

Поддержка <video> в действительности лишь малая часть проблемы. Прежде, чем мы поговорим об HTML5-видео, вам в первую очередь необходимо понять о самом видео.

## Контейнеры видео

Вы можете думать о видеофайлах как об «AVI» или «MP4». В действительности, «AVI» и «MP4» только форматы файлов. Подобно ZIP-архиву, в котором может храниться любой файл, видеоформаты определяют способ хранения, а не данные. В действительности все несколько сложнее из-за того, что потоковое видео не всегда совместимо с форматами контейнеров, но это пока не важно.

Видеофайл обычно содержит несколько дорожек — видеодорожка (без звука), а также одну или несколько звуковых дорожек (без видео). Дорожки, как правило, взаимосвязаны, звуковая дорожка содержит маркеры для синхронизации аудио с видео. Дополнительные дорожки могут содержать метаданные, такие как соотношение сторон видео или язык звуковой дорожки. Контейнеры также могут содержать метаданные, такие как название самого видео, обложку, номер эпизода (для сериалов) и др.

Существует много форматов контейнеров видео, вот некоторые самые популярные.

- [MPEG-4](http://ru.wikipedia.org/wiki/MPEG4), обычно с расширением mp4 или m4v. MPEG-4 основан на [старом контейнере Apple QuickTime](http://www.chiariglione.org/mpeg/technologies/mp04-ff/index.htm)(файлы с расширением mov). [Трейлеры к фильмам на сайте Apple](http://www.apple.com/trailers/) по-прежнему используют старый контейнер, но фильмы в iTunes поставляются в формате контейнера MPEG-4.
- [Ogg](http://ru.wikipedia.org/wiki/Ogg), обычно с расширением ogv. Ogg является открытым стандартом с открытым исходным кодом для пользователей, свободным от каких-либо патентов. Браузеры Firefox 3.5, Chrome 4 и Opera 10.5 имеют встроенную поддержку без специальных плагинов — контейнера Ogg, Ogg-видео (называемое «Theora») и Ogg-аудио (называемое «Vorbis»). Ogg поддерживается всеми основными дистрибутивами Linux, также можно использовать его на Mac и Windows, установив соответственно [компоненты QuickTime](http://www.xiph.org/quicktime/) или [фильтры DirectShow](http://www.xiph.org/dshow/). Плеер [VLC](http://www.videolan.org/vlc/) превосходно проигрывает Ogg-файлы на любой платформе.
- [Flash-видео](http://ru.wikipedia.org/wiki/Flash_Video), обычно с расширением flv. Для Flash-видео используется Adobe Flash, что не удивительно. До Flash 9.0.60.184 (по-другому Flash Player 9 Update 3) поддерживался только контейнер в формате Flash. Поздние версии также поддерживают контейнер MPEG-4.
- [WebM](http://ru.wikipedia.org/wiki/WebM), обычно с расширением webm. Является открытым стандартом, свободным от каких-либо патентов и разработан специально для использования с HTML5 видео, усилен видеокодеком VP8 и аудиокодеком Vorbis. Технически похож на другой формат, называемый [Matroska](http://en.wikipedia.org/wiki/Matroska). Поддерживается изначально, без отдельных плагинов, в последних версиях Google Chrome, Mozilla Firefox и Opera.
- [ASF](http://en.wikipedia.org/wiki/Advanced_Systems_Format), как правило, с расширением .asf. Формат контейнера ASF был изобретён Microsoft для потокового видео. Включала [восхитительную схему DRM](http://www.theinquirer.net/inquirer/news/1027669/microsoft-media-player-shreds-rights), которая ограничивала пользователям резервное копирование своих легально приобретённых лицензий. Таким образом, если по какой-то причине вы потеряли лицензию на содержимое, считали, что вы должны купить её ещё раз.
- [Audio Video Interleave](http://ru.wikipedia.org/wiki/Audio_Video_Interleave), как правило, с расширением avi. Формат контейнера AVI был изобретён Майкрософт в то время, когда считалось удивительным, что компьютеры вообще могут проигрывать видео. Особенности последних форматов файлов вроде метаданных официально не поддерживаются. Также этот формат официально не поддерживает большинство используемых современных аудио и видеокодеков. Он является форматом по умолчанию для популярных кодировщиков вроде MEncoder.

## Видеокодеки

Когда вы говорите о «просмотре видео», речь, вероятно, идёт о сочетании одного потока видео и одного аудиопотока. Но у вас нет двух разных файлов, есть «видео». Это может быть AVI-файл или MP4-файл, который всего лишь является форматом контейнера наподобие ZIP-архива, содержащего внутри себя несколько видов файлов. Формат контейнера определяет, как хранить видео и аудиопотоки в одном файле.

Когда вы смотрите видео, ваш плеер делает три вещи одновременно:

1. Интерпретирует формат контейнера, узнаёт, какие аудио и видеодорожки доступны, как они хранятся в файле, чтобы можно было найти данные.
2. Декодирует видеопоток и отображает серию изображений на экране.
3. Декодирует аудиопоток и отправляет звук на колонки.

Видеокодек это алгоритм, по которому кодируется видеопоток, он указывает, как сделать пункт 2 из списка выше. Слово «кодек» происходит от сочетания слов «кодер» и «декодер». Ваш видеоплеер декодирует видеопоток в зависимости от видеокодека, а затем отображает серию изображений или «кадров» на экране. Большинство современных видеокодеков использует всевозможные уловки для минимизации объёма информации, необходимого для отображения следующего кадра. Например, вместо хранения каждого отдельного кадра они будут хранить только различия между кадрами. Большинство видео на самом деле не изменяется целиком при переходе от одного кадра к другому, что позволяет хорошо сжимать данные, в результате получаются файлы меньшего размера.

Существуют видеокодеки с потерей данных и без потерь. Видео без потерь слишком большое, чтобы быть полезным в Интернете, поэтому я сконцентрируюсь на видео с потерями. Видеокодек с потерей означает, что информация во время кодирования безвозвратно утеряна. Это похоже на копирование аудиокассеты, вы теряете информацию об исходном видео и получаете ухудшения качества каждый раз, когда кодируете. Вместо «свиста» аудиокассеты пере-пере-перекодированное видео может выглядеть как набор блоков, особенно в сценах с движением. На самом деле это может произойти даже при кодировании из первоисточника, если вы выбрали плохой кодек или указали неверные параметры. Хорошей стороной видеокодеков с потерями является удивительное сглаживание блоков во время воспроизведения, что делает потери менее заметными для человеческого глаза.

Есть [куча видеокодеков](http://samples.mplayerhq.hu/V-codecs/). Три наиболее подходящих это H.264, Theora и VP8.

### H.264

[H.264](http://ru.wikipedia.org/wiki/H.264) также известен как «MPEG-4 Part 10» или «MPEG-4 AVC» или «MPEG-4 Advanced Video Coding». H.264 был разработан [группой MPEG](http://en.wikipedia.org/wiki/Moving_Picture_Experts_Group) и стандартизирован в 2003 году. Целью разработки было создание единого кодека для устройств от сотовых телефонов до современных настольных компьютеров. Для этого в стандарте H.264 имеются [профили](https://ru.wikipedia.org/wiki/H.264#.D0.9F.D1.80.D0.BE.D1.84.D0.B8.D0.BB.D0.B8), для каждого из которых определены дополнительные возможности влияющих на размер файла. Высшие профили используют несколько дополнительных функций, предлагают лучшее визуальное качество при меньших размерах файлов, но занимают больше времени для кодирования и требует больше ресурсов процессора для декодирования в реальном времени.

Чтобы дать вам примерное представление об ассортименте профилей, [iPhone от Apple поддерживает профиль Baseline](http://www.apple.com/iphone/specs.html), [приставка AppleTV поддерживает профили Baseline и Main](http://www.apple.com/appletv/specs.html), [Adobe Flash на настольных компьютерах поддерживает профили Basic, Main и High](http://www.kaourantin.net/2007/08/what-just-happened-to-video-on-web_20.html). YouTube использует H.264 для кодирования [видео высокого разрешения](http://blog.wired.com/business/2008/12/youtube-adds-hd.html), воспроизводимого через Adobe Flash; YouTube также предоставляет H.264-кодированное видео на мобильные устройства, включая iPhone от Apple и телефоны с [операционной системой Android](http://code.google.com/android/). Кроме того, H.264 является одним из видеокодеков, предусмотренных спецификацией Blu-Ray. Диски Blu-Ray используют в основном профиль High.

Большинство некомпьютерных устройств воспроизводящих H.264-видео (включая iPhone и бытовые Blu-Ray-проигрыватели) декодируют с помощью специального чипа, поскольку их основные процессоры не настолько мощны, чтобы декодировать видео в режиме реального времени. В наши дни даже бюджетные видеокарты имеют аппаратную поддержку декодирования H.264. Есть [конкурирующие с H.264 кодеки](http://compression.ru/video/codec_comparison/mpeg-4_avc_h264_2007_en.html), включая библиотеку с открытым кодом [x264](http://www.videolan.org/developers/x264.html). **Стандарт H.264 основан на патенте**, лицензирование происходит посредством группы [MPEG LA](http://www.mpegla.com/). H.264 может быть вложен в наиболее популярные [форматы видео](http://diveintohtml5.info/video.html#video-containers), включая MP4 (используется в основном в [магазине iTunes](http://www.apple.com/itunes/whatson/movies.html) компании Apple) и MKV (используется в основном энтузиастами видео).

### Theora

[Theora](http://ru.wikipedia.org/wiki/Theora) эволюционировал из [кодека VP3](http://en.wikipedia.org/wiki/Theora#History) и был разработан [Xiph.org Foundation](http://xiph.org/). **Theora — свободный от отчисления кодек и не связан никакими известными патентами** кроме оригинальных VP3-патентов, которые были лицензированы безвозмездно. Хотя стандарт был «заморожен» с 2004 года, проект Theora (включающий в себя кодер с открытым исходным кодом и декодер) [выпустил версию 1.0 в ноябре 2008 года](http://lists.xiph.org/pipermail/theora-dev/2008-November/003736.html) и [версию 1.1 в сентябре 2009 года](http://lists.xiph.org/pipermail/theora-dev/2009-September/003985.html).

Видео Theora может быть встроено в любой формат файла, хотя чаще всего встречается в контейнере Ogg. Все основные дистрибутивы Linux поддерживают Theora из коробки, Mozilla Firefox 3.5 включает в себя [встроенную поддержку видео Theora](https://developer.mozilla.org/En/Using_audio_and_video_in_Firefox) в контейнере Ogg. Вы также можете воспроизводить видео Theora в [Windows](http://www.xiph.org/dshow/) или в [Mac OS X](http://xiph.org/quicktime/) после установки открытого программного обеспечения Xiph.org.

### VP8

[VP8](http://ru.wikipedia.org/wiki/VP8) другой видеокодек от On2, той же компании, что первоначально разработала VP3 (позднее Theora). Технически по качеству он похож на базовый H.264 с большим потенциалом для будущих улучшений.

В 2010 году Google приобрел On2 и опубликовал спецификацию кодека и примеры как открытое программное обеспечение. В рамках этого Google также «открыл» все патенты, которые On2 зарегистрировала на VP8 и сделал их свободными от отчислений. Это лучшее, на что можно надеяться с патентами. Вы не можете на самом деле «освободить» их или свести на нет после того как они были выпущены. Чтобы сделать их открытыми для пользователей у вас должна быть лицензия без отчислений, после чего каждый может использовать технологию, ничего не платя и без заключения лицензионного соглашения. По состоянию на 19 мая 2010 года, VP8 является **свободным от отчислений, современным кодеком не связанным никакими известными патентами** кроме тех патентов, что On2 (в настоящее время Google) уже лицензировали безвозмездно.

## Аудиокодеки

Если вы собираетесь смотреть фильмы, снятые после [1927 года](http://www.filmsite.org/jazz.html), то захотите звуковую дорожку. Подобно видеокодеку, аудиокодек это алгоритм, согласно которому кодируется аудиопоток. Подобно видеокодеку они делятся на аудиокодеки с потерями и без. И аналогично видео без потерь, аудио без потерь слишком большое, чтобы выкладывать его в Интернет. Так что я сконцентрируюсь на аудиокодеках с потерями.

На самом деле, их не так и много, потому что есть разные категории кодеков с потерями. Аудио используется в тех местах, где нет видео (телефония, например), также существует категория [аудиокодеков оптимизированных для кодирования речи](http://www.voip-info.org/wiki-Codecs). Вам не удалось бы конвертировать музыкальный компакт-диск с этими кодеками, поскольку результат бы звучал как пение четырехлетнего ребенка. Но вы должны использовать их в [Asterisk](http://www.asterisk.org/), потому что ширина канала важна, а эти кодеки позволяют сжимать человеческую речь в разы по отношению к кодекам общего назначения. Тем не менее, из-за отсутствия поддержки в браузерах и сторонних плагинах, кодеки для оптимизации речи в реальности не используются в Интернете. Так что я сконцентрируюсь на общих аудиокодеках.

Как я уже упоминал выше, когда вы «смотрите видео», компьютер делает, по крайней мере, три вещи одновременно:

- интерпретирует формат контейнера;
- декодирует видеопоток;
- декодирует аудиопоток и направляет звук в колонки.

Аудиокодек отвечает за пункт 3 — декодирование аудиопотока и его преобразование в цифровые сигналы, которые динамики затем превращают в звук. Как и у видеокодеков имеются разные уловки для уменьшения объёма информации хранящейся в звуковом потоке.

И так как мы говорим о кодеках с потерями, информация теряется во время цикла запись → кодирование → декодирование → прослушивание. Различные аудиокодеки отбрасывают разные вещи, но у них всех одна цель: обмануть ваши уши — сделать так, чтобы вы не замечали пропавших частей.

Отличие аудио от видео в каналах. Мы отправляем звук на колонки, так? Ну, как много у вас колонок? Если вы сидите за компьютером, то скорее у вас их только две: одна слева и одна справа. На моем столе три: слева, справа и еще одна на полу. Системы, называемые «звук вокруг», могут содержать шесть и более динамиков, стратегически расположенных по всей комнате. Каждый динамик получает свой канал исходной записи. В теории вы можете сидеть в середине шести динамиков, буквально окруженный шестью раздельными каналами звука и ваш мозг будет вызывать чувство, что вы находитесь в центре событий. Это возможно? Индустрия за несколько миллиардов долларов думает что да.

Большинство общих аудиокодеков могут работать с двумя каналами звука. Во время записи звук разделяется на левый и правый каналы, во время кодирования оба канала хранятся в том же звуковом потоке, во время декодирования оба канала декодируются и каждый из них направляется в соответствующий динамик. Некоторые аудиокодеки могут обрабатывать более двух каналов, они отслеживают каждый канал, чтобы плеер посылал правильный звук на правильный динамик.

Есть много аудиокодеков. Я уже говорил, что видеокодеков много? Забудьте. Есть [уйма и уйма аудиокодеков](http://wiki.multimedia.cx/index.php?title=Category:Audio_Codecs), но в Интернете вам надо знать только об MP3, AAC и Vorbis.

### MPEG-1 Audio Layer 3

[MPEG-1 Audio Layer 3](http://ru.wikipedia.org/wiki/MP3) известен как «MP3». Если вы ничего не слышали об MP3, то я не знаю что с вами делать. Интернет-магазины продают портативные музыкальные плееры и называют их «MP3-плееры». Вот так.

MP3 может содержать **до двух каналов звука**, которые могут быть закодированы с различным битрейтом: 64 кбит/с, 128 кбит/с, 192 кбит/с и множество других от 32 до 320. Более высокий битрейт означает больший размер файлов и лучшее качество звука, хотя отношение битрейта к качеству звука не является линейным. 128 кбит/с звучит более чем в два раза лучше, чем 64 кбит/с, но 256 кбит/с не звучит в два раза лучше, чем 128 кбит/с. Кроме того, формат MP3 позволяет делать переменный битрейт, это означает что некоторые части кодированного потока сжаты больше других. Например, тишина может быть закодирована с низким битрейтом, затем мгновение спустя битрейт может подскочить, когда начнут играть несколько инструментов. MP3 также может быть закодирован с постоянным битрейтом.

Стандарт MP3 не определяет как именно кодировать MP3 (хотя он точно определяет как его декодировать), различные кодировщики используют разные психоакустические модели, которые дают широкий разброс результатов. Открытый [проект LAME](http://lame.sourceforge.net/) это лучший бесплатный кодировщик, за исключением самых низких битрейтов.

Формат MP3 (стандартизован в 1991) **запатентован**, что объясняет, почему Linux при установке из коробки не может проигрывать MP3-файлы. Почти каждый портативный музыкальный плеер поддерживает стандартные файлы MP3, аудиопоток в MP3 может быть встроен в любой [видеоконтейнер](http://web.archive.org/web/20100516164550/http://diveintomark.org/archives/2008/12/18/give-part-1-container-formats). Adobe Flash может играть и стандартные файлы MP3 и аудиопотоки MP3 в контейнере MP4-видео.

### Advanced Audio Coding

[Advanced Audio Coding](http://ru.wikipedia.org/wiki/Advanced_Audio_Coding) более известен как «AAC». Стандартизированный в 1997 году, он стал известным, когда Apple выбрал его в качестве основного формата для магазина iTunes.

Первоначально все AAC-файлы из магазина iTunes были зашифрованы фирменной DRM- схемой от Apple называемой [FairPlay](http://en.wikipedia.org/wiki/FairPlay). Избранные песни в iTunes теперь доступны как незащищённые AAC-файлы, их Apple называет «iTunes Плюс», потому что это звучит гораздо лучше, чем название «iTunes минус». **Формат AAC запатентован**, [лицензионное соглашение доступно в Интернете](http://www.vialicensing.com/licensing/aac-fees.aspx).

AAC был разработан, чтобы обеспечить лучшее качество звука чем MP3 при том же битрейте, и он может кодировать аудио в любой битрейт. MP3 ограничен фиксированным числом битрейтом с верхней границей 320 кбит/с. AAC может кодировать **до 48 каналов звука**, хотя на практике этого никто не делает. Формат AAC также отличается от MP3 заданием нескольких профилей, пойдя тем же путем что и [H.264](http://web.archive.org/web/20100510152646/http://diveintomark.org/archives/2008/12/19/give-part-2-lossy-video-codecs#h264). Профиль «low-complexity» предназначен для воспроизведения в реальном времени на устройствах с ограниченной мощностью процессора, в то время как более сложные профили предлагают лучшее качество звука при том же битрейте за счёт более медленного кодирования и декодирования.

Все современные продукты Apple, включая iPod, AppleTV, QuickTime поддерживают определенные профили AAC в стандартных аудиофайлах и аудиопотоках в видеоконтейнере MP4. Adobe Flash поддерживает все профили в формате AAC в MP4.

### Vorbis

[Vorbis](http://ru.wikipedia.org/wiki/Vorbis) часто называют «Ogg Vorbis» хотя это технически неверно — «Ogg» это формат контейнера, а Vorbis аудиопоток, который может быть встроен в другие контейнеры. **Vorbis не обременён никакими известными патентами** и, следовательно, поддерживается всеми основными дистрибутивами Linux и портативными устройствами. Mozilla Firefox 3.5 поддерживает Vorbis-аудио в контейнере Ogg или Ogg-видео с аудиодорожкой Vorbis. Мобильные телефоны на [Android](http://code.google.com/android/) также могут воспроизводить стандартные аудиофайлы Vorbis. Аудиопоток Vorbis, как правило, встроен в контейнер Ogg или WebM, но он также может быть [встроен в контейнер MP4](http://samples.mplayerhq.hu/MPEG-4/vorbis-in-mp4/) или [MKV](http://en.wikipedia.org/wiki/Matroska) (а также с некоторыми хитростями в [AVI](http://www.alexander-noe.com/video/amg/)). Vorbis поддерживает **произвольное количество звуковых каналов**.

Существуют свободные кодеры и декодеры Vorbis, в том числе [OggConvert](http://oggconvert.tristanb.net/) (кодер), [FFmpeg](http://www.ffmpeg.org/) (декодер), [aoTuV](http://www.geocities.jp/aoyoume/aotuv/) (кодер) и [libvorbis](http://downloads.xiph.org/releases/vorbis/) (декодер). Есть также [компоненты QuickTime для Mac OS X](http://www.xiph.org/quicktime/) и [фильтры DirectShow для Windows](http://www.xiph.org/dshow/).

## Что работает на странице

Если ваши глаза ещё окончательно не выпали, они у вас лучше, чем у большинства других. Как вы могли заметить, видео (и аудио) сложная тема, а ведь это ещё был сокращённый вариант! Я уверен, вам интересно как это всё относится к HTML5. Итак, HTML5 включает элемент <video> для встраивания видео на веб-страницу. Нет никаких ограничений на видеокодек, аудиокодек или формат файла, которые вы можете использовать для вашего видео. Один элемент <video> может содержать ссылки на несколько файлов, браузер же выберет первый файл, который он сможет воспроизвести. Это способ узнать, как браузеры поддерживают разные контейнеры и кодеки.

На момент написания статьи распространено следующее HTML5-видео.

- Mozilla Firefox 3.5+ поддерживает видео Theora и аудио Vorbis в контейнере Ogg. Firefox 4+ также поддерживает WebM.
- Opera 10.5+ поддерживает видео Theora и аудио Vorbis в контейнере Ogg. Opera 10.60+ также поддерживает WebM.
- Google Chrome 3.0+ поддерживает видео Theora и аудио Vorbis в контейнере Ogg. Он также поддерживает видео H.264 (все профили) и аудио AAC (все профили) в контейнере MP4. Google Chrome 6.0+ также поддерживает WebM.
- Safari на Маках и Windows (3.0 и выше) будет поддерживать всё, что поддерживает QuickTime. В теории вы могли бы потребовать, чтобы пользователи установили плагин QuickTime. В действительности лишь немногие пользователи это сделают. Так что остаются форматы, которые QuickTime поддерживает «из коробки». Это длинный список, но он не включает WebM, Theora, Vorbis или контейнер Ogg. Однако QuickTime поддерживает видео H.264 (основной профиль) и аудио AAC в контейнере MP4.
- Мобильные телефоны вроде iPhone от Apple и на базе Google Android поддерживают видео H.264 (базовый профиль) и аудио AAC (профиль «low-complexity») в контейнере MP4.
-  Adobe Flash (9.0.60.184 и выше) поддерживает видео H.264 (все профили) и аудио AAC (все профили) в контейнере MP4.
- Internet Explorer 9+ поддерживает все профили видео H.264 и аудио AAC или MP3 в контейнере MP4. Он также будет воспроизводить WebM, если вы установите сторонний кодек, который отсутствует по умолчанию в любой версии Windows. IE не поддерживает другие сторонние кодеки (в отличие от Safari, который воспроизводит всё, что понимает QuickTime).
- Internet Explorer 8 не поддерживает HTML5-видео вообще, но практически у всех пользователей Internet Explorer установлен плагин Adobe Flash. Далее в этой главе я покажу вам, как вы можете использовать HTML5-видео и изящно обратиться к Flash.

Нагляднее представить всё в виде таблицы.

| Кодек/контейнер   | IE    | Firefox | Safari | Chrome | Opera | iPhone | Android |
| ----------------- | ----- | ------- | ------ | ------ | ----- | ------ | ------- |
| Theora+Vorbis+Ogg | –     | 3.5+    | †      | 5.0+   | 10.5+ | –      | –       |
| H.264+AAC+MP4     | 9.0+  | –       | 3.0+   | 5.0+   | –     | 3.0+   | 2.0+    |
| WebM              | 9.0+* | 4.0+    | †      | 6.0+   | 10.6+ | –      | 2.3+    |

\* Internet Explorer 9 будет поддерживать WebM, только если пользователь установил VP8 кодек.

† Safari воспроизводит всё, что может играть QuickTime, но он работает только со встроенной комбинацией H.264/AAC/MP4.

А теперь удар нокаутом.

#### Профессор Разметкин говорит

Нет единой комбинации контейнеров и кодеков, которая работает во всех HTML5-браузерах. И эта ситуация вряд ли изменится в ближайшем будущем.

Чтобы ваше видео можно было смотреть на всех устройствах и платформах, придётся кодировать видео несколько раз.

Для обеспечения максимальной совместимости рабочий процесс с вашим видео будет следующим.

- Сделать одну версию с помощью WebM (VP8 + Vorbis).
- Сделать ещё одну версию, которая использует видео с базовым профилем H.264 и аудио AAC с профилем «low-complexity» в контейнере MP4.
- Сделать ещё одну версию, которая использует видео Theora и аудио Vorbis в контейнере Ogg. WebM и H.264 имеют достаточную поддержку. Так что если вы не собираетесь поддерживать Firefox 3.5 или Opera 10.5, можно отбросить Theora.
- В одном элементе <video> поставить ссылку на все три видеофайла и предусмотреть откат к плееру на Flash.

## Вопросы лицензирования видео H.264

Прежде чем мы продолжим, я должен отметить, что стоимость кодирования видео оплачивается два раза. Так, есть очевидная стоимость, когда вы хотите кодировать видео дважды, тогда требуется больше компьютеров и времени, чем для одного раза. Но есть и другая стоимость связанная с видео H.264 — это затраты на лицензирование.

Помните, когда я впервые объяснял про H.264 я заикался, что видеокодек запатентован и лицензируется при посредничестве консорциума MPEG LA. Это важное отклонение, для понимания этой важности я направляю вас на [The H.264 Licensing Labyrinth](http://www.streamingmedia.com/Articles/Editorial/Featured-Articles/The-H.264-Licensing-Labyrinth-65403.aspx).

> MPEG LA разделяет лицензию H.264 на две сублицензии: одну для производителей кодеров или декодеров, а другую для поставщиков...
>
> Сублицензия для поставщиков разделяется на четыре основных подкатегории, две из которых (подписка и платное использование) связаны с тем, что конечный пользователь непосредственно платит за видео сервисы, а ещё две («бесплатное» телевидение и интернет-трансляция) связаны с вознаграждением из других источников, а не от зрителя...
>
> Лицензионный сбор за «свободное» телевидение основан на одном из двух вариантов платежа. Первый это одноразовый платеж в размере $2500 за кодировщика передачи «используемый от имени лицензиата в передаче видео конечному пользователю», который будет декодировать и просматривать видео. Если вам интересно, является ли это двойной платой, ответ да: лицензионный сбор уже внесён в кодирующее устройство производителя, а телекомпании, в свою очередь платят один из двух вариантов роялти.
>
> Второй лицензионный платеж это плата за ежегодное вещание, которая зависит от размеров аудитории:
>
> - $2500 за один календарный год трансляции при аудитории 100.000–499.999 человек.
> - $5.000 за календарный год трансляции при аудитории 500.000–999.999 человек.
> - $10.000 за один календарный год трансляции при аудитории 1.000.000 человек и более.
>
> Как я упоминал ранее, плата за участие применяется к любому способу доставки контента. После определения, что «свободное» телевидение означает больше, чем обычное (по воздуху), MPEG LA установил частичную плату за интернет-вещание, так как «видео, которое поставляется через Интернет по всему миру, не оплачивается конечным пользователем за право на передачу или просмотр». Другими словами, любое вещание, является ли оно обычным, кабельным, спутниковым или через Интернет подлежит оплате...
>
> Сборы потенциально несколько выше для интернет-трансляций, предполагая, что доступ через Интернет будет расти гораздо быстрее, чем традиционное или «свободное» телевидение, такое как кабельное или спутниковое. Добавляя «бесплатное телевидение» в рынок вещания вместе с дополнительной оплатой, MPEG LA гарантирует отсрочку в течение первого срока лицензии, который заканчивается 31 декабря 2010 года, и отмечает, что «после первого срока роялти должен быть не более, чем экономический эквивалент лицензионного платежа в течение того же времени для свободного телевидения.

В последнюю часть — о структуре платы для интернет-трансляций — уже были внесены поправки. MPEG-LA недавно [объявила](http://www.mpegla.com/Lists/MPEG%20LA%20News%20List/Attachments/226/n-10-02-02.pdf), что для потокового вещания не потребуется отчислений. Это не означает что H.264 является безвозмездным для всех пользователей. В частности, кодеры (подобные тому, что обрабатывает видео, выложенное на YouTube) и декодеры (как включенный в браузер Google Chrome) все ещё являются предметом лицензионных сборов. Смотрите [Free as in smokescreen](http://shaver.off.net/diary/2010/08/27/free-as-in-smokescreen/) для получения дополнительной информации.

## Наконец, разметка

Я вполне уверен, что это должна быть книга по HTML. Тогда где разметка?

HTML5 предоставляет вам два способа включения видео на веб-страницу и оба связаны с элементом <video>. Если у вас есть только один видеофайл, вы можете дать ссылку на него в атрибуте src. Это очень похоже на добавление изображения через <img src="...">.

```
<video src="pr6.webm"></video>
```

Технически это всё что вам нужно. Но подобно элементу <img> вы должны всегда включать атрибуты width и height в <video>. Атрибуты width и height могут совпадать с максимальной шириной и высотой, которую вы указали во время процесса кодирования. Не беспокойтесь, если одна из сторон видео немного меньше указанных значений, ваш браузер центрирует видео внутри прямоугольника заданного элементом <video>. Пропорции видео никогда не будут искажены.

```
<video src="pr6.webm" width="320" height="240"></video>
```

По умолчанию для элемента <video> не добавляются кнопки управления. Вы можете создать собственные элементы управления со старым добрым HTML, CSS, и JavaScript. Для <video> действуют такие методы как play() и pause (), а также свойство currentTime. Есть также свойства volume и muted. Так что вы имеете всё необходимое для создания своего собственного интерфейса.

Если вы не желаете создавать свой интерфейс, то можете сказать браузеру вывести встроенные элементы управления. Для этого просто включите атрибут controls в <video>.

```
 <video src="pr6.webm" width="320" height="240" controls></video>
```

Есть ещё два дополнительных атрибута, о которых я хотел бы упомянуть, прежде чем мы пойдём дальше: preloadи autoplay. Не стреляйте в посланника, позвольте мне вначале объяснить, почему они полезны. Атрибут preloadсообщает браузеру, что вы хотели бы начать загрузку видеофайлов, как только страница загрузится. Это имеет смысл, если страница предназначена для просмотра важного видео. С другой стороны, если это просто дополнительный материал, то лишь немногие посетители будут его смотреть, тогда вы можете установить preloadкак none, чтобы сказать браузеру снизить сетевой трафик.

Вот пример видео, которое начинает загрузку (но не воспроизведение), как только загрузится страница.

```
<video src="pr6.webm" width="320" height="240" preload></video>
```

А вот пример видео, которое не будет загружаться при загрузке страницы.

```
<video src="pr6.webm" width="320" height="240" preload="none"></video>
```

Атрибут autoplay делает именно то, как и звучит: говорит браузеру, что вы хотели бы начать загрузку видеофайла при загрузке страницы и желаете воспроизвести видео при возможности автоматически. Некоторые люди любят это, другие ненавидят. Но позвольте мне объяснить, почему этот атрибут важен в HTML5. Отдельные люди хотят, чтобы их видео воспроизводилось автоматически, даже если это раздражает их посетителей. Если HTML5 не определяет стандартный способ автоматического воспроизведения видео, люди начнут прибегать к JavaScript, чтобы сделать это в любом случае. Например, вызывать метод play() пока загружаются события окна. Посетителям было бы гораздо труднее противодействовать этому. С другой стороны, это упрощает добавление в расширение браузера (или написать сво` при необходимости) выражения «игнорировать атрибут autoplay, я не желаю воспроизводить видео автоматически».

Вот пример видео, которое начнет загружаться и играть сразу же после загрузки страницы.

```
 <video src="pr6.webm" width="320" height="240" autoplay></video>
```

А вот скрипт Greasemonkey, который можно установить в вашей локальной копии Firefox для предотвращения автоматического воспроизведения HTML5-видео. Он использует DOM-атрибут autoplay определённый в HTML5 и эквивалентный атрибуту autoplay в коде HTML.

```
var arVideos = document.getElementsByTagName('video');
for (var i = arVideos.length - 1; i >= 0; i--) {
  var elmVideo = arVideos[i];
  elmVideo.autoplay = false;
}
```

Но подождите секунду... Если вы следовали этой главе, то у вас есть не один видеофайл, а три. Один это OGV-файл, второй MP4-файл, третий WebM-файл. HTML5 обеспечивает способ сделать ссылки на все три файла с помощью элемента <source>. Каждый элемент <video> может содержать более одного <source>. Ваш браузер пройдётся по списку источников видео по порядку и выберет первым то, что он в состоянии воспроизвести.

Возникает другой вопрос: как браузер узнает, какое видео он сможет воспроизвести? Ну, в худшем случае он загружает каждое видео и пытается его сыграть, однако это большая трата пропускной способности. Вы сэкономите много трафика, если сообщите браузеру информацию о каждом видео. Это можно сделать атрибутом type элемента <source>.

```
<video width="320" height="240" controls>
  <source src="pr6.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'>
  <source src="pr6.webm" type='video/webm; codecs="vp8, vorbis"'>
  <source src="pr6.ogv" type='video/ogg; codecs="theora, vorbis"'>
</video>
```

Давайте разберём это сверху вниз. Элемент <video> определяет ширину и высоту видео, но не ссылку на видеофайл. Внутри <video> содержится три элемента <source>. Каждый элемент <source> ссылается на отдельный видеофайл (с атрибутом src), а также даёт информацию о видеоформате (в атрибуте type).

Тип атрибута выглядит сложным, адски сложным. Это комбинация из трёх блоков информации: формат файла, видеокодек и аудиокодек. Давайте начнём с самого последнего. Для видеофайла .ogv формат контейнера — Ogg, представленный здесь как video/ogg, строго говоря, это MIME-тип для видеофайлов Ogg. Видеокодек Theora и аудиокодек Vorbis. Это достаточно просто, кроме формата значение атрибута, он немного странный. Само значение должно быть заключено в кавычки, поэтому вы должны использовать различные виды кавычек, чтобы окружить значение целиком.

```
<source src="pr6.ogv" type='video/ogg; codecs="theora, vorbis"'>
```

С WebM почти так же, но с другим MIME-типом (video/webm вместо video/ogg) и другим видеокодеком (vp8 вместо theora) написанным в параметре codecs.

```
<source src="pr6.webm" type='video/webm; codecs="vp8, vorbis"'>
```

Видео H.264 является более сложным. Помните, я говорил, что видео H.264 и аудио AAC может быть в разных «профилях»? Мы кодируем H.264 с помощью «базового» профиля и AAC с профилем «low-complexity» и все это внутри контейнера MPEG-4. Вся информация, включенная в атрибут type.

```
 <source src="pr6.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'>
```

Преимуществом всех этих сложностей является то, что браузер проверяет атрибут type первым и смотрит, может ли он воспроизвести видеофайл. Если браузер решает, что он не может этого сделать, то не будет скачивать файл даже частично. Вы сэкономите на пропускной способности, а ваши посетители увидят видео, за которым они пришли, быстрее.

Если вы будете следовать инструкциям этой главы при кодировании видео, то можете просто скопировать и вставить значения атрибута type из примеров. В противном случае, вам нужно выработать параметры type для себя.

#### Профессор Разметкин говорит

iPad на iOS 3.x содержал ошибку, из-за которой он не замечал ничего, кроме первого источника видео в списке. iOS 4 исправил эту ошибку. Если вы ориентируйтесь на владельцев старых устройств, то это означает, что вы должны указать ваш MP4-файл первым, а затем остальные видеоформаты. Эх.

## MIME-типы поднимают свою уродливую голову

Неправильно настроенный веб-сервер может привести к бесконечным разочарованиям, почему это ваши видео идут на локальном компьютере, но не воспроизводятся на рабочем сайте. Если вы столкнулись с этой проблемой, то причина вероятнее всего в MIME-типах.

Я уже упоминал про MIME-типы ранее, но вы, вероятно, прозевали и не оценили их значение. Так вот большими буквами.

#### Профессор Разметкин говорит

ВИДЕОФАЙЛЫ ДОЛЖНЫ БЫТЬ СОПОСТАВЛЕНЫ С СООТВЕТСТВУЮЩИМ MIME-ТИПОМ!

Что это за соответствующий MIME-тип? Вы уже видели его как часть значения атрибута type у элемента <source>. Но добавление атрибута type не является достаточным, вы также должны убедиться, что ваш веб-сервер включает в HTTP-заголовок Content-Type соответствующий MIME-тип.

Если вы используйте веб-сервер Apache или его производные, то можете включить директиву AddType в httpd.conf или файл .htaccess расположенный в той директории, где вы храните ваши видеофайлы. Если вы используете другой веб-сервер, обратитесь к документации вашего сервера о том, как установить HTTP-заголовок Content-Type для определенных типов файлов.

```
  AddType video/ogg .ogv
  AddType video/mp4 .mp4
  AddType video/webm .webm
```

Первая строка предназначена для видео в контейнере Ogg. Вторая строка для видео в контейнере MPEG-4. Третья для WebM. Установите это один раз и забудьте. Если вы не указали эти директивы, ваше видео может не играть в некоторых браузерах, даже если включены MIME-типы в атрибуте type вашего HTML-кода.

Для суровых подробностей по настройке веб-сервера, я обращаю ваше внимание на эту прекрасную статью в Mozilla Developer Center: [Configuring servers for Ogg media](https://developer.mozilla.org/en/Configuring_servers_for_Ogg_media). Советы в этой статье также относятся к видео MP4 и WebM.

## Что насчет IE?

[Internet Explorer 9 поддерживает](http://msdn.microsoft.com/en-us/ie/ff468705.aspx#_HTML5_video_audio) элемент <video>, но Microsoft публично пообещал, что финальная версия IE 9 будет поддерживать видео H.264 и аудио AAC в формате контейнера MPEG-4, как Safari и iPhone.

Но как насчёт более старых версий Internet Explorer до IE8 включительно? У большинства людей, которые используют Internet Explorer также установлен плагин Adobe Flash. Современные версии Adobe Flash (начиная с 9.0.60.184) поддерживают видео H.264 и аудио AAC в формате контейнера MPEG-4, как Safari и iPhone. После того как вы кодировали видео H.264 для Safari, вы можете проиграть его во Flash-плеере, если обнаружится что у одного из посетителей не HTML5-браузер.

Flash-видеоплеер [FlowPlayer](http://flowplayer.org/) это программа с открытым кодом по GPL-лицензии (коммерческая лицензия также доступна). FlowPlayer ничего не знает об элементе <video>, он не будет волшебным образом преобразовывать тег <video> во Flash-объект. Но HTML5 хорошо продуман, чтобы обойти эту проблему, поэтому вы можете вложить элемент <object> внутрь <video>. Браузеры, которые не поддерживают HTML5-видео, будут игнорировать элемент <video> и просто отображать вложенный <object> который ссылается на плагин Flash и показывает кино через FlowPlayer. Браузеры, поддерживающие HTML5-видео, обнаружат источник видео, который они могут воспроизвести и проигнорируют вложенный элемент <object>.

Это последний ключ ко всей головоломке: HTML5 указывает, что все элементы (кроме <source>) внутри <video>должны игнорироваться. Это позволяет использовать HTML5-видео в новых браузерах и красиво откатить к Flash в старых браузерах, без каких-либо трюков с JavaScript. Вы можете почитать об этой технике здесь: [Video For Everybody](http://camendesign.com/code/video_for_everybody).

## Проблемы с iPhone и iPad

iOS это операционная система Apple для iPhone, iPod Touche и iPad. iOS 3.2 имеет ряд проблем с HTML5-видео.

- iOS не распознает видео, если вставлен атрибут poster. Этот атрибут элемента <video> позволяет отображать произвольное изображение при загрузке видео или пока пользователь нажимает на кнопку «играть». Эта ошибка исправлена в iOS 4.0, но пройдёт какое-то время пока пользователи обновятся.
- Если у вас несколько элементов <source>, iOS признает лишь первый в списке. Устройства с iOS поддерживают только H.264 + AAC + MP4, это фактически означает, что вы всегда должны указывать MP4-файл в первую очередь. Эта ошибка также исправлена в iOS 4.0.

## Проблемы с устройствами на базе Android

Android — это операционная система Google для разных телефонов и карманных устройств. Android (до версии 2.3) имеет ряд проблем с HTML5-видео.

- Атрибут type элемента <source> порядочно «смущает» Android. Единственный способ заставить его признать источник видео это по иронии судьбы вообще опустить атрибут type и убедиться, что имя вашего видеофайла H.264 + AAC + MP4 заканчивается расширением .mp4. Это, кажется, не влияет на способность любого другого браузера определять поддержку видео; при отсутствии атрибута type другие браузеры смотрят на расширение файла. Вы еще можете включить атрибут type для других источников видео, так как H.264 является единственным форматом видео, который поддерживается устройствами Android на данный момент.
- Атрибут controls не поддерживается и Android не будет отображать любые элементы управления для видео. Вам будет нужно обеспечить собственные элементы управления пользовательского интерфейса. Как минимум, вы должны сделать скрипт, который начинает проигрывать видео, когда пользователь на него нажимает.

## И наконец, живой пример

В окончательном коде используется элемент <video>, вложенный элемент <object> для резервного Flash и небольшой скрипт для устройств на Android.

```
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Видео</title>
  </head>
  <body>
    <video id="movie" width="400" height="320" preload controls>
      <source src="video/snowman.mp4">
      <source src="video/snowman.webm" type='video/webm; codecs="vp8, vorbis"'>
      <source src="video/snowman.ogv" type='video/ogg; codecs="theora, vorbis"'>
      <object id="flowplayer" type="application/x-shockwave-flash" 
                              width="400" height="320">
        <param name="movie" value="video/flowplayer-3.2.5.swf"> 
        <param name="flashvars" value='config={"clip":"video/snowman.mp4"}'>
        <p>Загрузить видео в <a href="video/snowman.mp4">MP4</a>, 
           <a href="video/snowman.ogv">OGG</a> или 
           <a href="video/snowman.webm">WebM</a></p>
      </object>    
    </video>
    <script>
      var v = document.getElementById("movie");
      v.onclick = function() {
        if (v.paused) {
          v.play();
        } else {
          v.pause();
        }
      };
    </script>
  </body>
</html>
```

При сочетании HTML5 и Flash вы сможете смотреть это видео практически на любом устройстве и браузере.

## Дальнейшее чтение

- [HTML5: The  element](http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#video)
- [Video for Everybody](http://camendesign.com/code/video_for_everybody)
- [A gentle introduction to video encoding](http://web.archive.org/web/20100527215322/http://diveintomark.org/tag/give)
- [Theora 1.1 is released — what you need to know](http://hacks.mozilla.org/2009/09/theora-1-1-released/)
- [Configuring servers for Ogg media](https://developer.mozilla.org/en/Configuring_servers_for_Ogg_media)
- [Encoding with the x264 codec](http://www.mplayerhq.hu/DOCS/HTML/en/menc-feat-x264.html)
- [Video type parameters](http://wiki.whatwg.org/wiki/Video_type_parameters)
- [Everything you need to know about HTML5 audio and video](http://dev.opera.com/articles/view/everything-you-need-to-know-about-html5-video-and-audio/)
- [Making HTML5 video work on Android phones](http://www.broken-links.com/2010/07/08/making-html5-video-work-on-android-phones/)
- [Internet Explorer 9 Guide for Developers: HTML5 video and audio elements](http://msdn.microsoft.com/en-us/ie/ff468705.aspx#_HTML5_video_audio)

Создание своего управления для видео:

- [VideoJS](http://videojs.com/)
- [MediaElement.js](http://mediaelementjs.com/)
- [Kaltura HTML5 Video & Media JavaScript Library](http://www.kaltura.org/project/HTML5_Video_Media_JavaScript_Library)