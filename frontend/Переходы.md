# Переходы

[Главная](https://webref.ru/) / [Вёрстка](https://webref.ru/layout) / [HTML5 и CSS3 на примерах](https://webref.ru/layout/html5-css3) / Переходы /

[Комментариев: 17](https://webref.ru/layout/html5-css3/transition#disqus_thread)

Переходом называется плавная смена свойств элемента при наведении на него курсора мыши. При использовании псевдокласса :hover изменение происходит мгновенно, transition же позволяет задать продолжительность и метод перехода.

Рассмотрим для начала простой пример. У нас имеется несколько картинок, каждая из них должна поворачиваться на небольшой угол при наведении на неё курсора (пример 1).

Пример 1. Применение transition

```
<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8">
  <title>Поворот картинок</title>
  <style>
   .thumb {
    display: inline-block;
    border: 1px solid #ccc; /* Параметры рамки */
    padding: 20px; /* Поля вокруг картинки */
    margin-right: 30px; /* Отступ справа */
    box-shadow: 0 0 5px #ccc; /* Добавляем тень  */
    transition: 0.6s ease-out; /* Переход */
   }
   .thumb:hover {
    transform: rotate(-15deg); /* Поворачиваем картинку */
    border: 1px solid green; /* Меняем цвет рамки */
   }
  </style>
 </head>
 <body> 
  <div class="thumb"><img src="images/thumb1.jpg" alt=""></div>
  <div class="thumb"><img src="images/thumb2.jpg" alt=""></div>
  <div class="thumb"><img src="images/thumb3.jpg" alt=""></div>
 </body>
</html>
```

[Живой пример](http://jsfiddle.net/webref/589v0mk8/)

Как только мы наводим курсор на любую картинку, она плавно поворачивается на 15 градусов влево (рис. 1).

![Плавный поворот изображения](https://webref.ru/assets/images/html5-css3/transition.png)

Рис. 1. Плавный поворот изображения

В стилях для :hover мы устанавливаем желаемые изменения элементов при наведении курсора. Сам переход добавляется в стилях элемента через свойство transition. У него четыре параметра — одно или несколько свойств, продолжительность анимации, функция времени и задержка времени перед анимацией.

**Свойства**

По умолчанию анимируются все свойства указанные внутри :hover. Иногда часть свойств должна анимироваться, а часть нет. В этом случае все желаемые свойства следует перечислить через запятую в transition.

```
transition: transform, border 1s;
```

**Продолжительность анимации**

Это время, в течение которого будет длиться движение. Задаётся как в секундах (1s, 0.5s), так и в миллисекундах (100ms).

**Задержка анимации**

Движение не обязательно должно начинаться немедленно, допустимо добавить в начале небольшую задержку, после завершения заданного времени сразу же начнётся анимация.

**Функция времени**

Анимация может происходить по разному. Например, медленно начинаться в начале движения и ускоряться в конце или наоборот. Вариантов множество и они создают всевозможные интересные эффекты. Скорость анимации управляется специальной функцией связывающей время и движение. Вот как она выглядит на графике (рис. 2).

![Вид функции времени](https://webref.ru/assets/images/css/css_timing-function-1.png)

Рис. 2. Вид функции времени

Начальная точка имеет координаты 0.0, 0.0, конечная — 1.0, 1.0, при этом функция по оси ординат может превышать эти значения в большую или меньшую сторону. В итоге это будет выглядеть, словно элемент сперва движется в обратную сторону, а потом уже в нужную. Так можно создать эффект отскакивания или инерции. Вот наиболее популярные значения функции времени.

- ease — анимация начинается медленно, затем ускоряется и к концу движения опять замедляется.
- ease-in — анимация медленно начинается, к концу ускоряется.
- ease-out — анимация начинается быстро, к концу замедляется.
- ease-in-out — анимация начинается и заканчивается медленно.
- linear — одинаковая скорость от начала и до конца.

В примере 2 переход применяется для плавного выдвижения панели из-за левого края экрана при наведении на неё курсора мыши.

Пример 2. Использование функции времени

```
<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8">
  <title>Обратная связь</title>
  <style>
   .feedback {
    border-radius: 0 10px 10px 0; /*  Скругляем уголки */
    width: 300px; /* Ширина */
    background: #333; /* Цвет фона */
    color: #fff; /* Цвет текста */
    position: fixed; /* Фиксируем на одном месте  */
    min-height: 100px; /* Минимальная высота */
    top: 100px; left: -320px; /* Положение */
    border-right: 20px solid #fc0; /* Оранжевая граница справа */
    padding: 10px; /* Поля вокруг */
    transition: left 1s ease-out; /* Анимация */
   }
   .feedback img {
    float: left;
    margin: 0 10px 0 0;
   }
   .feedback::after {
    content: 'Обратная связь'; /* Выводим текст */
    color: #000; /* Цвет надписи */
    position: absolute; /* Абсолютное позиционирование */
    right: -60px; bottom: 50px; /* Положение текста */
    transform: rotate(-90deg); /* Поворачиваем текст */
   }
   .feedback:hover {
    left: 0; /* При наведении сдвигаем вправо */
   }
  </style>
 </head>
 <body>
  <div class="feedback">
   <img src="images/feedback.jpg" alt="" width="100" height="100">
   Если у вас возникли вопросы по этому коду, звоните мне по телефону:
   555-3298. 
  </div>
 </body>
</html>
```

[Живой пример](http://jsfiddle.net/webref/83uwrwv0/)

В данном примере много стилевых свойств, но они предназначены лишь для создания нужного дизайна. Анимация при наведении курсора мыши делается двумя свойствами — transition задаёт параметры анимации, а left — это свойство, значение которого плавно изменяется со временем (в данном случае в течение одной секунды). Исходно left равно -320px и большая часть панели скрыто за левым краем браузера, виден лишь кусочек. Затем left становится равным нулю и таким образом вся панель становится видна.

В стилях допускается добавлять сразу несколько transition одновременно с разными свойствами и эффектами, это позволяет разнообразить переходы. В примере 3 показано создание кнопки, у которой плавно изменяется цвет фона, границы и надписи. При этом анимация текста отличается от анимации других частей.

Пример 3. Кнопка с плавным изменением цвета

```
<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8">
  <title>Кнопка</title>
  <style>
   button {
    background-color: #828c95;
    color: #fff;
    font-size: 1.5em;
    padding: 10px 40px;
    border-radius: 20px;
    border: 2px solid #b5bdc8;
    transition: background-color, border 1s ease-in, color 2s ease-out; 
   }
   button:hover {
    background-color: #fac695;
    color: #333;
    border: 2px solid #ff670f;
   }
  </style>
 </head>
 <body>
  <button>Нажми на меня</button>
 </body>
</html>
```

[Живой пример](http://jsfiddle.net/webref/pf27v4do/)

Если вам требуется задействовать несколько transition с разными значениями, то их нельзя просто перечислить друг за другом. Нижнее свойство всегда будет переопределять верхние. Так что мы пишем один transition, а через запятую перечисляем необходимые нам параметры.

[переходы](https://webref.ru/metki/perehody)





# Переходы в CSS

[Главная](https://webref.ru/) / [Учебные курсы](https://webref.ru/course) / [Продвинутый CSS](https://webref.ru/course/css-advanced) / Переходы в CSS /

[Комментариев: 5](https://webref.ru/course/css-advanced/transitions#disqus_thread)

- [Описание](https://webref.ru/course/css-advanced/transitions#content)
- [Задания](https://webref.ru/course/css-advanced/transitions#task)

**Переходы** в CSS позволяют плавно перейти от одного состояния элемента к другому. Работает это так, что отдельные **свойства** анимируются от **начального** состояния до **конечного**.

Вы можете определить:

- transition-property: какие **свойства** анимируются;
- transition-duration: **как долго** длится анимация;
- transition-timing-function: как вычисляются **промежуточные состояния**;
- transition-delay: анимация начинается **через** некоторое время.

Вы можете установить каждое свойство CSS по отдельности или использовать сокращённую версию: transition. В этом случае, только transition-duration является **обязательным**.

Имейте в виду, что переход представляет собой **специфический вид** *анимации*, **где есть только начальное и конечное состояние**.

## Быстрый пример

Переходы часто используются для состояния :hover.

```
a { background: lightgrey; color: grey; }
a:hover { background: yellow; color: red; }
a.with-transition { transition: 1s; }
```

Вместо **мгновенного** применения правил CSS при наведении, фон и цвет текста меняются медленно.

## transition-duration

transition-duration является единственным стилевым свойством, необходимым для создания перехода. Оно может быть установлено либо в **секундах** (2s), либо в **миллисекундах** (100ms).

Если вы хотите, чтобы ваш переход длился **полсекунды**, то можете написать 0.5s или 500ms. В зависимости от того, насколько быстро вы хотите, чтобы длился переход, может быть проще и/или быстрее писать одну единицу.

```
a { background: lightgrey; color: grey; }
a:hover { background: yellow; color: red; }
a.with-fast-transition { transition: 0.5s; }
a.with-slow-transition { transition: 3s; }
```

## transition-property

Только **треть** свойств CSS может быть анимирована. На сайте Mozilla есть [полный список](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties) свойств.

По умолчанию у свойства transition-property значение all, это просто означает, что будут анимироваться все возможные свойства.

Вы можете разрешить анимацию только одного или нескольких свойств.

```
a { background: lightgrey; color: grey; }
a:hover { background: yellow; border: 5px solid blue; color: green; }
a.with-background-transition { transition-duration: 2s; transition-property: background; }
a.with-all-transition { transition: 2s; }
```

Свойство border полностью анимируется и позволяет легко наблюдать медленный переход (2 секунды).

## transition-timing-function

Функция времени определяет, как вычисляется **значение** каждого свойства **во время перехода**.

По умолчанию переход равен ease: он ускоряется в начале и замедляется в конце.

Вы можете решить, что переход будет происходить с **постоянной скоростью**. Функция времени может **ускорить**или **замедлить** переход.

Самый простой способ визуализации функций времени заключается в изменении **свойств позиционирования**, вроде left.

CSS

```
div { left: 0; position: relative; transition: 1s; }
main:hover div { left: 200px; }
.ease { transition-timing-function: ease; } /* Поведение по умолчанию */
.linear { transition-timing-function: linear; } /* Постоянная скорость */
.ease-in { transition-timing-function: ease-in; }
.ease-out { transition-timing-function: ease-out; }
.ease-in-out { transition-timing-function: ease-in-out; }
```

HTML

```
<main>
  <p><strong>ease</strong>: медленно начинается, быстро в середине, медленно завершается</p>
  <div class="ease"></div>
  <p><strong>linear</strong>: постоянная скорость</p>
  <div class="linear"></div>
  <p><strong>ease-in</strong>: медленно начинается, быстро завершается</p>
  <div class="ease-in"></div>
  <p><strong>ease-out</strong>: быстро начинается, медленно завершается</p>
  <div class="ease-out"></div>
  <p><strong>ease-in-out</strong>: похоже на ease, но с более выраженным ускорением/замедлением</p>
  <div class="ease-in-out"></div>
</main>
```

Имейте в виду, что все переходы занимают **одинаковое время** (1 секунда).

Если вы хотите получить представление, как работают другие функции времени, посмотрите [эту шпаргалку](http://easings.net/ru).

### cubic-bezier

Если все эти **готовые** функции времени не подходят, вы можете написать свою собственную, используя **кривые Безье**.

Сайт [cubic-bezier.com](http://cubic-bezier.com/) — это простой инструмент для визуального написания своих собственных кривых.

## transition-delay

transition-delay определяет задержку, т. е. как долго переход должен **ждать**, *прежде* чем начнётся на самом деле.

Как и с transition-duration вы можете использовать секунды (s) или миллисекунды (ms).

CSS

```
a { background: blue; color: white; transition: all 1s; }
div:hover a { background: red; }
a.with-delay { transition-delay: 1s; }
```

HTML

```
<div>
  <p>Наведите курсор на серую область</p>
  <a>Без задержки</a>
  <a class="with-delay">С секундной задержкой</a>
</div>
```

[Перейти к заданиям](https://webref.ru/course/css-advanced/transitions#lesson-tabs)





# Переходы в CSS

[Главная](https://webref.ru/) / [Учебные курсы](https://webref.ru/course) / [Продвинутый CSS](https://webref.ru/course/css-advanced) / Переходы в CSS /

[Комментариев: 5](https://webref.ru/course/css-advanced/transitions#disqus_thread)

- [Описание](https://webref.ru/course/css-advanced/transitions#content)
- [Задания](https://webref.ru/course/css-advanced/transitions#task)

**Переходы** в CSS позволяют плавно перейти от одного состояния элемента к другому. Работает это так, что отдельные **свойства** анимируются от **начального** состояния до **конечного**.

Вы можете определить:

- transition-property: какие **свойства** анимируются;
- transition-duration: **как долго** длится анимация;
- transition-timing-function: как вычисляются **промежуточные состояния**;
- transition-delay: анимация начинается **через** некоторое время.

Вы можете установить каждое свойство CSS по отдельности или использовать сокращённую версию: transition. В этом случае, только transition-duration является **обязательным**.

Имейте в виду, что переход представляет собой **специфический вид** *анимации*, **где есть только начальное и конечное состояние**.

## Быстрый пример

Переходы часто используются для состояния :hover.

```
a { background: lightgrey; color: grey; }
a:hover { background: yellow; color: red; }
a.with-transition { transition: 1s; }
```

Вместо **мгновенного** применения правил CSS при наведении, фон и цвет текста меняются медленно.

## transition-duration

transition-duration является единственным стилевым свойством, необходимым для создания перехода. Оно может быть установлено либо в **секундах** (2s), либо в **миллисекундах** (100ms).

Если вы хотите, чтобы ваш переход длился **полсекунды**, то можете написать 0.5s или 500ms. В зависимости от того, насколько быстро вы хотите, чтобы длился переход, может быть проще и/или быстрее писать одну единицу.

```
a { background: lightgrey; color: grey; }
a:hover { background: yellow; color: red; }
a.with-fast-transition { transition: 0.5s; }
a.with-slow-transition { transition: 3s; }
```

## transition-property

Только **треть** свойств CSS может быть анимирована. На сайте Mozilla есть [полный список](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties) свойств.

По умолчанию у свойства transition-property значение all, это просто означает, что будут анимироваться все возможные свойства.

Вы можете разрешить анимацию только одного или нескольких свойств.

```
a { background: lightgrey; color: grey; }
a:hover { background: yellow; border: 5px solid blue; color: green; }
a.with-background-transition { transition-duration: 2s; transition-property: background; }
a.with-all-transition { transition: 2s; }
```

Свойство border полностью анимируется и позволяет легко наблюдать медленный переход (2 секунды).

## transition-timing-function

Функция времени определяет, как вычисляется **значение** каждого свойства **во время перехода**.

По умолчанию переход равен ease: он ускоряется в начале и замедляется в конце.

Вы можете решить, что переход будет происходить с **постоянной скоростью**. Функция времени может **ускорить**или **замедлить** переход.

Самый простой способ визуализации функций времени заключается в изменении **свойств позиционирования**, вроде left.

CSS

```
div { left: 0; position: relative; transition: 1s; }
main:hover div { left: 200px; }
.ease { transition-timing-function: ease; } /* Поведение по умолчанию */
.linear { transition-timing-function: linear; } /* Постоянная скорость */
.ease-in { transition-timing-function: ease-in; }
.ease-out { transition-timing-function: ease-out; }
.ease-in-out { transition-timing-function: ease-in-out; }
```

HTML

```
<main>
  <p><strong>ease</strong>: медленно начинается, быстро в середине, медленно завершается</p>
  <div class="ease"></div>
  <p><strong>linear</strong>: постоянная скорость</p>
  <div class="linear"></div>
  <p><strong>ease-in</strong>: медленно начинается, быстро завершается</p>
  <div class="ease-in"></div>
  <p><strong>ease-out</strong>: быстро начинается, медленно завершается</p>
  <div class="ease-out"></div>
  <p><strong>ease-in-out</strong>: похоже на ease, но с более выраженным ускорением/замедлением</p>
  <div class="ease-in-out"></div>
</main>
```

Имейте в виду, что все переходы занимают **одинаковое время** (1 секунда).

Если вы хотите получить представление, как работают другие функции времени, посмотрите [эту шпаргалку](http://easings.net/ru).

### cubic-bezier

Если все эти **готовые** функции времени не подходят, вы можете написать свою собственную, используя **кривые Безье**.

Сайт [cubic-bezier.com](http://cubic-bezier.com/) — это простой инструмент для визуального написания своих собственных кривых.

## transition-delay

transition-delay определяет задержку, т. е. как долго переход должен **ждать**, *прежде* чем начнётся на самом деле.

Как и с transition-duration вы можете использовать секунды (s) или миллисекунды (ms).

CSS

```
a { background: blue; color: white; transition: all 1s; }
div:hover a { background: red; }
a.with-delay { transition-delay: 1s; }
```

HTML

```
<div>
  <p>Наведите курсор на серую область</p>
  <a>Без задержки</a>
  <a class="with-delay">С секундной задержкой</a>
</div>
```

[Перейти к заданиям](https://webref.ru/course/css-advanced/transitions#lesson-tabs)





# Относительное позиционирование

[Главная](https://webref.ru/) / [Учебные курсы](https://webref.ru/course) / [Позиционирование элементов](https://webref.ru/course/position) / Относительное позиционирование /

[0 комментариев](https://webref.ru/course/position/relative#disqus_thread)

- [Описание](https://webref.ru/course/position/relative#content)
- [Задания](https://webref.ru/course/position/relative#task)

Если задать значение relative для свойства position, то положение элемента устанавливается относительно его исходного места. Добавление свойств left, top, right и bottom изменяет позицию элемента и сдвигает его в ту или иную сторону от первоначального расположения. Положительное значение left определяет сдвиг вправо от левой границы элемента, отрицательное — сдвиг влево. Положительное значение top задаёт сдвиг элемента вниз (рис. 1), отрицательное — сдвиг вверх.

![Значения свойств left и top при относительном позиционировании](https://webref.ru/assets/images/position/relative-1.png)

Рис. 1. Значения свойств left и top при относительном позиционировании

Свойства bottom и right производят обратный эффект. При положительном значении right сдвигает элемент влево от его правого края, при отрицательном — сдвигает вправо (рис. 2). При положительном значении bottom элемент поднимается вверх, при отрицательном опускается вниз.

![Значения свойств right и bottom при относительном позиционировании](https://webref.ru/assets/images/position/relative-2.png)

Рис. 2. Значения свойств right и bottom при относительном позиционировании

Для относительного позиционирования характерны следующие особенности:

- элемент можно смещать относительно исходного положения с помощью свойств left, right, top и bottom;
- при смещении элемента относительно исходного положения, место, которое занимал элемент, остаётся пустым и не заполняется ниже или вышележащими элементами;
- если сдвинуть элемент вправо за пределы окна браузера, то появится горизонтальная полоса прокрутки;
- если сдвинуть элемент вниз за пределы окна браузера, то появится вертикальная полоса прокрутки;
- смещение элемента влево и вправо за пределы окна браузера не оказывает влияния на полосы прокрутки;
- работает свойство z-index;
- этот тип позиционирования неприменим к элементам таблицы вроде ячеек, строк, колонок и др.

В примере 1 показан сдвиг текста заголовка вниз для придания ему особого стиля написания.

Пример 1. Заголовок текста

```
<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8">
  <title>Заголовок</title>
  <style>
   h1 {
    font: normal 2em Arial, Tahome, sans-serif; /* Параметры шрифта */
    background: #3989c9; /* Синий цвет фона */
    color: #fff; /* Белый цвет текста */
    padding: 0 1rem; /* Поля вокруг заголовка */
    overflow: hidden; /* Скрываем всё за пределами заголовка */
   }
   h1 span {
    position: relative; /* Относительное позиционирование */
    top: 0.48rem; /* Сдвигаем вниз */
   }
  </style>
 </head>
 <body>
  <h1><span>Аз и буки шрифтовой науки</span></h1>
  <p>Шрифт это средство выражения дизайна, а не какого-то 
  банального чтения.</p>
 </body>
</html>
```

Результат данного примера показан на рис. 3.

![Сдвиг текста относительно исходного положения](https://webref.ru/assets/images/position/relative-3.png)

Рис. 3. Сдвиг текста относительно исходного положения

Относительное позиционирование часто применяется для создания анимации и эффектов, связанных со сдвигом элементов. В примере 2 с помощью элемента <button> добавляется кнопка с тенью, при наведении курсора на кнопку она смещается вправо и вниз на величину тени, а сама тень при этом прячется. Всё это в комплексе придаёт кнопке трёхмерный эффект.

Пример 2. Сдвиг кнопки

```
<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8">
  <title>Кнопка</title>
  <style>
   button {
    background: #CE242B; /* Красный фон */
    color: #fff; /* Белый цвет текста */
    border: none; /* Убираем рамку */
    padding: .7rem 2rem; /* Поля вокруг текста */
    box-shadow: 5px 5px 0 #000; /* Параметры тени */
    position: relative; /* Относительное позиционирование */
    left: 0; /* Положение слева */
    top: 0; /* Положение сверху */
    transition: 1s; /* Время анимации */
   }
   button:hover {
    left: 5px; /* Положение слева */
    top: 5px; /* Положение сверху */
    box-shadow: 0 0 0 #000; /* Параметры тени */
   }
  </style>
 </head>
 <body>
  <button>Кнопка</button>
 </body>
</html>
```

Наведите курсор на кнопку, чтобы увидеть анимацию в действии. Время движения кнопки определяется свойством [transition](https://webref.ru/css/transition).

Для относительно позиционированных элементов работает свойство z-index, которое управляет положением элементов по оси Z. Если требуется задать наложение элементов относительно друг друга, то в стилях достаточно указать position со значением relative без смещения самого элемента. В примере 3 выводятся картинки, при наведении на них курсора они увеличиваются в размерах и отображаются поверх остальных изображений.

Пример 3. Использование z-index

```
<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8">
  <title>z-index</title>
  <style>
   img {
    border: 1px solid #ce242b; /* Параметры рамки */
    position: relative; /* Относительное позиционирование */
    transition: 1s; /* Время анимации */
   }
   img:hover {
    z-index: 10; /* Поверх всех картинок */
    transform: scale(1.2); /* Масштабирование на 20% */
   }
  </style>
 </head>
 <body>
  <img src="image/thumb1.jpg" alt="">
  <img src="image/thumb2.jpg" alt="">
  <img src="image/thumb3.jpg" alt="">
 </body>
</html>
```

Посмотреть пример в действии можно ниже.

[Перейти к заданиям](https://webref.ru/course/position/relative#lesson-tabs)



# Свойства позиционирования

[Главная](https://webref.ru/) / [Учебные курсы](https://webref.ru/course) / [Позиционирование элементов](https://webref.ru/course/position) / Свойства позиционирования /

[0 комментариев](https://webref.ru/course/position/property#disqus_thread)

- [Описание](https://webref.ru/course/position/property#content)
- [Задания](https://webref.ru/course/position/property#task)

Для изменения типа позиционирования применяется свойство [position](https://webref.ru/css/position). Само по себе это свойство используется крайне редко и как правило идёт в комбинации со свойствами [left](https://webref.ru/css/left), [right](https://webref.ru/css/right), [top](https://webref.ru/css/top), [bottom](https://webref.ru/css/bottom), которые определяют, соответственно, положение элемента слева, справа, сверху и снизу.

- left — задаёт координаты левого края элемента от левого края родителя или левого края исходного положения элемента.
- right — задаёт координаты правого края элемента от правого края родителя или правого края исходного положения элемента.
- top — задаёт координаты верхнего края элемента от верхнего края родителя или верхнего края исходного положения элемента.
- bottom — задаёт координаты нижнего края элемента от нижнего края родителя или нижнего края исходного положения элемента.

Заметьте, что напрямую нельзя задать положение правого края элемента от левого края родителя и наоборот. Также нельзя задать положение верхнего края элемента от нижнего края родителя и наоборот.

У position есть пять значений.

- **static** — нормальное или статичное позиционирование, при этом элементы отображаются на веб-странице в том порядке, в каком они идут в исходном коде HTML сверху вниз. static — это значение по умолчанию для position.
- **relative** — относительное позиционирование. Изменяет положение элемента от его исходного расположения.
- **absolute** — абсолютное позиционирование. Элемент при этом не существует в потоке документа и его положение задаётся относительно краёв браузера.
- **fixed** — фиксированное позиционирование. По своему действию похоже на абсолютное позиционирование, но в отличие от него привязывается к указанной свойствами left, top, right и bottom точке на экране и не меняет своего положения при прокрутке веб-страницы.
- **sticky** — липкое позиционирование. Обычно применяется для фиксации заголовка на одном месте, пока содержимое, к которому относится заголовок, прокручивается на странице.

Свойство position не наследуется, так что для дочерних элементов его требуется указывать явно.

Для изменения положения элементов по оси Z применяется свойство [z-index](https://webref.ru/css/z-index), которое непосредственно связано со свойством position. z-index работает только для элементов, у которых position задано как relative, absolute или fixed.

[Перейти к заданиям](https://webref.ru/course/position/property#lesson-tabs)

## См. также





# Абсолютное позиционирование

[Главная](https://webref.ru/) / [Учебные курсы](https://webref.ru/course) / [Позиционирование элементов](https://webref.ru/course/position) / Абсолютное позиционирование /

[0 комментариев](https://webref.ru/course/position/absolute#disqus_thread)

- [Описание](https://webref.ru/course/position/absolute#content)
- [Задания](https://webref.ru/course/position/absolute#task)

При абсолютном позиционировании элемент не существует в потоке документа и его положение задаётся относительно краёв браузера. Установить этот тип можно через значение absolute свойства position. Координаты указываются относительно краёв окна браузера, называемого «видимой областью» или «областью просмотра» (рис. 1).

![Значения свойств left, right, top и bottom при абсолютном позиционировании](https://webref.ru/assets/images/position/absolute-1.png)

Рис. 1. Значения свойств left, right, top и bottom при абсолютном позиционировании

Для элемента с абсолютным позиционированием характерны следующие особенности.

- Ширина элемента, если она не задана явно, определяется шириной содержимого плюс значения padding, border и margin.
- Элемент не меняет своё исходное положение, если у него нет свойств right, left, top и bottom.
- Одновременно указанные свойства left и right формируют ширину элемента, но только если width не указано. Стоит добавить свойство width и значение right будет проигнорировано. Аналогично произойдёт и с высотой элемента, но уже участвуют свойства top, bottom и height.
- Свойства left и top имеют более высокий приоритет по сравнению с right и bottom. Если left и right противоречат друг другу, то значение right игнорируется. То же самое касается и bottom.
- Если left задать отрицательное значение, то элемент уйдёт за левый край браузера, полосы прокрутки при этом не возникнет. То же относится и к свойству top, только элемент уйдёт за верхний край.
- Если left задать значение больше ширины видимой области или указать right с отрицательным значением, то появится горизонтальная полоса прокрутки. Подобное правило работает и с top, только речь пойдёт о вертикальной полосе прокрутки.
- Элемент перемещается вместе с документом при его прокрутке.
- Работает свойство [z-index](https://webref.ru/css/z-index), при абсолютно позиционированные элементы перекрывают статичные элементы, даже если они в коде ниже.

Свойство position со значением absolute можно использовать для создания эффекта фреймов. Кроме абсолютного позиционирования для элементов следует назначить свойство [overflow](https://webref.ru/css/overflow) со значением auto. Тогда, если содержимое превысит высоту видимой области, появится полоса прокрутки. Высота и ширина «фреймов» формируется автоматически путём одновременного использования свойств left, right для ширины и top, bottom для высоты (пример 1).

Пример 1. Имитация фреймов

```
<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8">
  <title>Фреймы</title>
  <style>
   body { margin: 0; /* Убираем отступы */ }
   .sidebar, .content { 
    position: absolute; /* Абсолютное позиционирование */
    overflow: auto; /* Полосы прокрутки при необходимости */
    padding: 10px; /* Поля вокруг текста */
    top: 61px; /* Расстояние от верхнего края */
    bottom: 0; /* Расстояние от нижнего края */
   }
   header {
    height: 60px; /* Высота */
    background: #FEDFC0; /* Цвет фона */
    border-bottom: 1px solid #7B5427; /* Линия снизу */
   }
   header h1 { 
    line-height: 60px; /* Выравниваем по середине */
    margin: 0 10px; /* Сдвигаем заголовок */
   }
   .sidebar { 
    width: 150px; /* Ширина */
    background: #ECF5E4; /* Цвет фона */
    border-right: 1px solid #231F20; /* Линия справа */
   }
   .content {
    left: 171px; /* Расстояние от левого края */ 
    right: 0; /* Расстояние справа */
   }
  </style>
 </head>
 <body>
  <header><h1>Плов народов мира</h1></header>
  <section class="sidebar">
   <p>Плов по-фергански</p><p>Плов узбекский</p>
   <p>Плов сибирский</p><p>Плов итальянский</p>
   <p>Плов эстонский</p><p>Плов по-американски</p>
   <p>Плов по-индейски</p>
  </section>
  <section class="content">
   <h2>Плов по-фергански</h2>
   <p>Положить в казан нарезанное кусочками мясо и поджарить его до 
   образования корочки. Нашинкованный кольцами лук жарить вместе 
   с мясом до красноватого цвета, затем добавить морковь, нарезанную 
   соломкой. Положить половину соли, всё перемешать и жарить, пока 
   морковь не приобретёт золотисто-коричневый цвет. После этого налить 
   половину необходимого количества воды и дать закипеть.</p> 
   <p>Засыпать ровным слоем рис, усилить огонь и тотчас налить воду, 
   чтобы она накрыла рис на 1–1,5 см. Как только вода выпарится, плов 
   при помощи шумовки собрать к середине горкой, проколоть палочкой в 
   нескольких местах так, чтобы вода, находящаяся на поверхности, 
   прошла на дно. Затем накрыть плов и дать ему упреть 20–25 мин.</p>
   <p>Тщательно перемешайте готовый плов, переложите в большое блюдо, 
   сверху разложите мясо.</p>
  </section>
 </body>
</html>
```

Результат данного примера показан на рис. 2. Элемент <header> выводится в потоке как обычно, а для sidebar и content установлено абсолютное позиционирование.

![Имитация фреймов на веб-странице](https://webref.ru/assets/images/position/absolute-2.png)

Рис. 2. Имитация фреймов на веб-странице

Тот же самый приём, когда мы задаём размеры элемента с помощью свойств left, right, top и bottom, применяется для создания разных эффектов. К примеру, можно сделать затемнение веб-страницы для вывода сообщения и привлечения к нему внимания. В примере 2 добавляется элемент с классом overlay, размеры которого занимают всю область просмотра. Делаем его полупрозрачного чёрного цвета, а поверх отображаем блок с классом dialog, который выводится по центру горизонтали.

Пример 2. Затемнение веб-страницы

```
<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8">
  <title>Диалог</title>
  <style>
   .overlay {
    position: absolute; /* Абсолютное позиционирование */
    left: 0; right: 0; top: 0; bottom: 0; /* Занимает всё пространство */
    background: rgba(0, 0, 0, 0.8); /* Полупрозрачный цвет фона */
   }
   .dialog {
    position: absolute; /* Абсолютное позиционирование */
    background: #fff; /* Цвет фона */
    width: 260px; /* Ширина */
    padding: 20px; /* Поля */
    min-height: 180px; /* Минимальная высота */
    left: 0; right: 0; /* Нужно для выравнивания */
    margin: 80px auto 0; /* Выравниваем по центру */
   }
  </style>
 </head>
 <body>
  <div class="overlay"></div>
  <div class="dialog"><h2>Сообщение</h2></div>
  <p>Богатство мировой литературы от Платона до Ортеги-и-Гассета 
  свидетельствует о том, что культурная аура произведения вызывает 
  определенный метод кластерного анализа, что-то подобное можно 
  встретить в работах Ауэрбаха и Тандлера.</p>
 </body>
</html>
```

Результат данного примера показан на рис. 3.

![Диалоговое окно с затемнением](https://webref.ru/assets/images/position/absolute-3.png)

Рис. 3. Диалоговое окно с затемнением

Обратите внимание, что для вывода абсолютно позиционированного элемента по центру горизонтали применяется следующий стиль.

```
.dialog {
  width: 260px;
  left: 0; right: 0;
  margin-left: auto; margin-right: auto;
}
```

Таким образом, сочетание width, left, right и margin управляет выравниванием элементов.

Абсолютное позиционирование позволяет также скрывать элементы. Для этого часто добавляется стиль left: -9999px, который переносит элемент далеко влево за область просмотра. В частности, этот приём используется для стилизации переключателей и флажков, когда мы скрываем настоящий флажок, а вместо него стилизуем элемент <label>, связанный с <input> и выполняющим его функции (пример 3).

Пример 3. Стилизация флажка

```
<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8">
  <title>Флажок</title>
  <style>
   .checkbox {
    width: 28px; /* Ширина переключателя */
    height: 28px; /* Высота переключателя */
    background: #333; /* Цвет рамки */
   }
   .checkbox input[type=checkbox] {
    position: absolute; /* Абсолютное позиционирование */
    left: -9999px; /* Скрываем элемент */
   }
   .checkbox input[type=checkbox]:checked + label {
    background: #009d4b; /* Цвет фона включенного переключателя */
   }
   .checkbox label {
    display: block; /* Блочный элемент */
    width: 20px; /* Ширина */
    height: 20px; /* Высота */
    position: relative; /* Относительное позиционирование */
    left: 4px; top: 4px; /* Смещаем вправо и вниз */
    background: #fff; /* Цвет фона выключенного переключателя */
   }
  </style>
 </head>
 <body>
  <div class="checkbox">
   <input type="checkbox" id="c1" checked>
   <label for="c1"></label>
  </div>
 </body>
</html>
```

Результат данного примера в действии можно посмотреть ниже.

[Перейти к заданиям](https://webref.ru/course/position/absolute#lesson-tabs)



# Липкое позиционирование

[Главная](https://webref.ru/) / [Учебные курсы](https://webref.ru/course) / [Позиционирование элементов](https://webref.ru/course/position) / Липкое позиционирование /

[0 комментариев](https://webref.ru/course/position/sticky#disqus_thread)

- [Описание](https://webref.ru/course/position/sticky#content)
- [Задания](https://webref.ru/course/position/sticky#task)

Липкое или приклеенное позиционирование используется для фиксации элемента в заданном месте при прокрутке страницы. Как правило, применяется к заголовкам, меню или навигации для быстрого к ним доступа или наглядности. В демонстрации ниже при прокрутке веб-страницы вниз синий блок с навигацией доходит до верхнего края окна и «приклеивается» к нему, фиксируясь на одном месте.

В данной демонстрации липкое позиционирование осуществляется с помощью значения sticky свойства position. При этом с помощью свойства top мы указываем точку, по достижении которой при прокрутке элемент превращается в фиксированный (пример 1).

Пример 1. Использование sticky

```
<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8">
  <title>Приклеенная навигация</title>
  <style>
   body {
    min-height: 1000px; /* Минимальная высота */
   }
   header, nav {
    color: #fff; /* Цвет текста */
    padding: 10px; /* Поля */
   }
   header {
    background: #009d4b; /* Цвет фона */
   }
   nav {
    background: #3989c9; /* Цвет фона */
    position: sticky; /* Липкое позиционирование */
    top: 0; /* Положение сверху */
   }
  </style>
 </head>
 <body>
  <header>Название сайта</header>
  <nav>Навигация по сайту</nav>
 </body>
</html>
```

Следует понимать, что при вертикальной прокрутке для элемента имеет смысл указывать только top и bottom. При горизонтальной прокрутке будут работать только свойства left и right. Также имеет значение, чтобы высота или ширина родительского контейнера была больше размера элемента. В противном случае не будет полосы прокрутки и элемент останется на своём месте. Если в примере 1 элемент <nav> поместить внутрь <div>, то прилипание перестанет работать.

Прилипание элемента можно делать внутри блока с [overflow](https://webref.ru/css/overflow), у которого значение задано как scroll или auto(пример 2).

Пример 2. Использование sticky и overflow

```
<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8">
  <title>Приклеенный заголовок</title>
  <style>
   section {
    height: 200px; /* Высота */
    background: #f0f0f0; /* Цвет фона */
    border: 1px solid #000; /* Параметры рамки */
    overflow: auto; /* Добавляем полосы прокрутки */
   }
   h2 {
    background: #009d4b; /* Цвет фона */
    color: #fff; /* Цвет текста */
    padding: 10px; /* Поля вокруг текста */
    position: sticky; /* Приклеиваем заголовок */
    top: 0; /* К верхнему краю родителя */
   }
   div {
    min-height: 500px; /* Минимальная высота */
    padding: 10px; /* Поля вокруг текста */
   }
  </style>
 </head>
 <body>
  <section>
   <h2>Заголовок</h2>
   <div>…</div>
  </section>
 </body>
</html>
```

Результат данного примера в действии можно посмотреть ниже.

Значение sticky является относительно новым и не все браузеры его поддерживают, в частности, Internet Explorer.

[Перейти к заданиям](https://webref.ru/course/position/sticky#lesson-tabs)



# Нормальное позиционирование

[Главная](https://webref.ru/) / [Учебные курсы](https://webref.ru/course) / Position / Нормальное позиционирование /

[0 комментариев](https://webref.ru/course/position/static#disqus_thread)

- [Описание](https://webref.ru/course/position/static#content)
- [Задания](https://webref.ru/course/position/static#task)

Если для элемента свойство position не задано или его значение явно указано как static, элемент выводится в потоке документа как обычно. Иными словами, элементы отображаются на странице в том порядке, как они идут в исходном коде HTML. static — это значение свойства position по умолчанию, иными словами, если вы не задали для элемента position, то оно считается браузером как static.

Формально, static не является типом позиционирования, это естественное исходное состояние любого элемента. Таким образом, термины «нормальное позиционирование», «обычное позиционирование», «статичное позиционирование», «статичный элемент» указывают лишь на значение static у свойства position, поскольку позиционирования как такового нет и элемент остаётся на своём начальном месте.

Для нормального позиционирования характерны следующие особенности:

- элементы на веб-странице выводятся в том порядке, как они описаны в коде HTML;
- свойства left, right, top и bottom не дают никакого эффекта;
- свойство z-index не работает.

В примере 1 показан вывод трёх элементов с нормальным позиционированием.

Пример 1. Вывод элементов

```
<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8">
  <title>static</title>
  <style>
   .box {
    min-height: 60px; /* Минимальная высота */
    margin-bottom: 10px; /* Отступ снизу */
   }
   .box-1 {
    background: #CE242B; /* Красный фон */
   }
   .box-2 {
    background: #009D4B; /* Зелёный фон */
   }
   .box-3 {
    background: #3989C9; /* Синий фон */
   }
  </style>
 </head>
 <body>
  <div class="box box-1"></div>
  <div class="box box-2"></div>
  <div class="box box-3"></div>
 </body>
</html>
```

В данном примере в коле HTML перечислены элементы с классами box-1, box-2, box-3, они выводятся на веб-странице в этом же порядке (рис. 1).

![Вывод элементов с нормальным позиционированием](https://webref.ru/assets/images/position/static.png)

Рис. 1. Вывод элементов с нормальным позиционированием

Само по себе значение static применяется редко, поскольку является значением по умолчанию и не требует явного указания. Оно используется на практике лишь для возврата свойства position к начальному значению. В примере 2 для элемента задано относительное позиционирование и оно сдвинуто вниз от своего исходного положения. Псевдокласс :hover отменяет относительное позиционирование и элемент возвращается в исходное положение, если навести на него курсор.

Пример 2. Использование static

```
<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8">
  <title>static</title>
  <style>
   .box-1 {
    background: #CE242B; /* Красный фон */
    min-height: 60px; /* Минимальная высота */
    position: relative; /* Относительное позиционирование */
    top: 20px; /* Расстояние сверху */
   }
   .box-1:hover {
    position: static; /* Статичное позиционирование */
   }
  </style>
 </head>
 <body>
  <div class="box-1"></div>
 </body>
</html>
```

[Перейти к заданиям](https://webref.ru/course/position/static#lesson-tabs)





# иксированное позиционирование

[Главная](https://webref.ru/) / [Учебные курсы](https://webref.ru/course) / [Позиционирование элементов](https://webref.ru/course/position) / Фиксированное позиционирование /

[0 комментариев](https://webref.ru/course/position/fixed#disqus_thread)

- [Описание](https://webref.ru/course/position/fixed#content)
- [Задания](https://webref.ru/course/position/fixed#task)

Фиксированное позиционирование элемента задаётся значением fixed свойства position и по своему действию похоже на абсолютное позиционирование. Но в отличие от него привязывается к указанной свойствами left, top, right и bottom точке на экране и не меняет своего положения при прокрутке веб-страницы.

Для фиксированного позиционирования характерны следующие особенности.

- При прокрутке веб-страницы элемент остаётся на своём исходном месте.
- Положение элемента всегда отсчитывается от области просмотра браузера, независимо от позиционирования родителя.
- При выходе элемента за пределы видимой области справа или снизу от неё, не возникает полос прокрутки и элемент просто «обрезается».

В остальном, значение fixed похоже на absolute.

Применяется такой тип позиционирования для создания меню, вкладок, заголовков, в общем, любых элементов, которые должны быть закреплены на веб-странице и всегда видны посетителю. В примере 1 показано добавление «шапки», которая остаётся на одном месте независимо от объёма информации на сайте.

Пример 1. Использование fixed

```
<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8">
  <title>Шапка</title>
  <style>
   header {
    position: fixed; /* Фиксированное позиционирование */
    left: 0; right: 0; /* Вся ширина */
    top: 0; /* Положение сверху */
    padding: 10px; /* Поля вокруг текста */
    background: #3989c9; /* Цвет фона */
    color: #fff; /* Цвет текста */
   }
   header h1 {
    margin: 0; /* Убираем отступы */
   }
   main {
    min-height: 1000px; /* Минимальная высота */
    margin-top: 70px; /* Отступ сверху */
    display: block; /* Для IE */
   }
  </style>
 </head>
 <body>
  <header><h1>Название сайта</h1></header>
  <main>
   <p>Умножение вектора на число, исключая очевидный случай, 
   позиционирует интеграл по поверхности.</p>
  </main>
 </body>
</html>
```

Результат примера показан на рис. 1. Поскольку фиксированный элемент накладывается на текст и скрывает его, добавлен отступ сверху для <main>. Тем самым текст сдвигается вниз на высоту «шапки».

![Фиксированная «шапка»](https://webref.ru/assets/images/position/fixed-1.png)

Рис. 1. Фиксированная «шапка»

fixed подобно absolute также может использоваться для вывода диалоговых окон и сообщений, но при этом фиксированное сообщение невозможно прокрутить вверх или вниз, оно всегда остаётся на своём месте. В примере 2 для вывода блока в центре веб-страницы мы позиционируем его с помощью свойств left и top со значением 50%. При этом ровно по центру окажется левый верхний угол, поэтому весь блок смещаем влево и вверх на половину его ширины и высоты с помощью свойства [transform](https://webref.ru/css/transform). Размеры блока вычисляется автоматически и равны размеру содержимому плюс значения padding.

Пример 2. Фиксированный блок

```
<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8">
  <title>Сообщение</title>
  <style>
   .msg {
    position: fixed; /* Фиксированное позиционирование */
    padding: 10px; /* Поля вокруг текста */
    background: #009d4b; /* Цвет фона */
    color: #fff; /* Цвет текста */
    left: 50%; top: 50%; /* Выводим в центре */
    transform: translate(-50%, -50%); /* Смещаем влево и вверх */
   }
   body {
    min-height: 1000px; /* Минимальная высота */
   }
  </style>
 </head>
 <body>
  <div class="msg">Всё в порядке, сайт удалён!</div>
 </body>
</html>
```

Результат данного примера показан на рис. 2.

![Сообщение в центре веб-страницы](https://webref.ru/assets/images/position/fixed-2.png)

Рис. 2. Сообщение в центре веб-страницы

[Перейти к заданиям](https://webref.ru/course/position/fixed#lesson-tabs)





# Позиционирование содержимого

[Главная](https://webref.ru/) / [Вёрстка](https://webref.ru/layout) / [Уроки по HTML и CSS](https://webref.ru/layout/learn-html-css) / Позиционирование содержимого /

[Комментариев: 32](https://webref.ru/layout/learn-html-css/positioning-content#disqus_thread)

Одной из лучших сторон CSS является то, что стили дают нам возможность позиционировать содержимое и элементы на странице практически любым мыслимым образом. Это вносит структурность в наш дизайн и помогает сделать контент более наглядным.

Есть несколько разных типов позиционирования в CSS, каждый из этих типов имеет свою область действия. В этой главе мы собираемся взглянуть на несколько различных случаев применения — создание многократно используемых макетов и уникальное позиционирование одноразовых элементов, а также описание нескольких методов как это сделать.

## Позиционирование через float

Один из способов позиционирования элементов на странице — через свойство float. Это свойство довольно универсально и может применяться разными путями.

По существу, свойство float берёт элемент, убирает его из обычного потока страницы и позиционирует слева или справа от родительского элемента. Все остальные элементы на странице будут обтекать такой элемент. Например, абзацы будут обтекать изображение, если для элемента <img> установлено свойство float.

Когда свойство float применяется к нескольким элементам одновременно, это даёт возможность создать макет с обтекаемыми элементами расположенными рядом или напротив друг друга, как показано в многоколоночном макете.

Свойство float принимает несколько значений, два самых популярных — это left и right, они позволяют элементу располагаться слева или справа от своего родителя.

```
img {
  float: left;
}
```

### float на практике

Давайте создадим общий макет страницы с шапкой вверху, двумя колонками в центре и подвалом внизу. В идеале эту страницу следует разметить с помощью элементов <header>, <section>, <aside> и <footer>, как описано в уроке 2 «Знакомство с HTML». Внутри элемента <body> HTML может выглядеть так:

```
<header>...</header>
<section>...</section>
<aside>...</aside>
<footer>...</footer>
```

### Демонстрация макета без float

Здесь элементы <section> и <aside> являются блочными, поэтому они укладываются один поверх другого по умолчанию. Однако мы хотим, чтобы эти элементы располагались бок о бок. Установив float для <section> как left, а для <aside> как right, мы можем позиционировать их как две колонки, расположенных напротив друг друга. Наш CSS должен выглядеть так:

```
section {
  float: left;
}
aside {
  float: right;
}
```

Для справки, обтекаемые элементы располагаются по краю родительского элемента. Если нет родителя, обтекаемый элемент будет располагаться по краю страницы.

Когда мы устанавливаем элемент обтекаемым, то убираем его из обычного потока HTML-документа. Это приводит к тому, что ширина этого элемента по умолчанию становится шириной его содержимого. Иногда, например, когда мы создаём колонки для многократно используемого макета, такое поведение нежелательно. Это можно исправить путём добавления свойства width с фиксированным значением для каждой колонки. Кроме того, чтобы обтекаемые элементы не соприкасались друг с другом, в результате чего содержимое одного элемента располагается рядом с другим, мы можем использовать свойство margin, чтобы установить пространство между элементами.

Ниже мы расширяем предыдущий блок кода, добавив margin и width для каждой колонки, чтобы лучше формировать наш желаемый результат.

```
section {
  float: left;
  margin: 0 1.5%;
  width: 63%;
}
aside {
  float: right;
  margin: 0 1.5%;
  width: 30%;
}
```

### Демонстрация макета с float

### float могут изменить значение display у элемента

Для обтекаемого элемента также важно понимать, что элемент удаляется из обычного потока страницы и что у элемента может измениться значение display, заданное по умолчанию. Свойство float опирается на то, что у элемента значение display задано как block и может изменить значение display у элемента по умолчанию, если он ещё не отображается как блочный элемент.

Например, элемент, у которого display указан как inline, такой как строчный <span>, игнорирует любые свойства height или width. Однако, если для строчного элемента указать float, значение display изменится на block и тогда элемент уже может принимать свойства height или width.

Когда мы применяем float для элемента, то должны следить за тем, как это влияет на значение свойства display.

Для двух колонок вы можете установить float, для одной колонки как left, а для другой как right, но для нескольких колонок нам придётся изменить наш подход. Скажем, к примеру, мы хотели бы получить ряд из трёх колонок между нашими элементами <header> и <footer>. Если мы выбросим наш элемент <aside> и воспользуемся тремя элементами <section>, наш HTML может выглядеть следующим образом:

```
<header>...</header>
<section>...</section>
<section>...</section>
<section>...</section>
<footer>...</footer>
```

Чтобы расположить эти три элемента <section> в строку из трёх колонок, мы должны задать float для всех элементов <section> как left. Мы также должны настроить ширину <section> с учётом дополнительных колонок и расположить их один рядом с другим.

```
section {
  float: left;
  margin: 0 1.5%;
  width: 30%;
}
```

Здесь у нас есть три колонки, все с равной шириной и значением margin, а также с float, заданным как left.

### Демонстрация трёхколоночного макета с float

### Очистка и содержимое float

Свойство float было первоначально разработано, чтобы позволить содержимому обтекать вокруг изображений. Для изображения может быть задано float и всё содержимое вокруг этого изображения, естественно, обтекает вокруг него. Хотя это прекрасно работает для картинок, свойство float на самом деле не было предназначено для использования в макете и с целью позиционирования и, таким образом, оно идёт с несколькими ловушками.

Одной из этих ловушек является то, что иногда надлежащие стили не отображаются на элементе, который расположен рядом с обтекаемым элементом или является его родителем. Когда элемент установлен обтекаемым, то он убирается из обычного потока страницы и, как результат, стили элементов вокруг этого обтекаемого элемента могут получить негативное влияние.

Часто значения свойств margin и padding интерпретируются некорректно, заставляя их сливаться с обтекаемым элементом. Другие свойства также могут быть затронуты.

Другая ошибка состоит в том, что иногда нежелательный контент начинает обтекать элемент с float. Удаление элемента из потока документа позволяет всем элементам вокруг обтекаемого элемента обходить его и задействовать любое доступное пространство вокруг обтекаемого элемента, что часто бывает нежелательно.

В нашем предыдущем примере с двумя колонками, после того как мы добавили float к элементам <section> и <aside>, но до того как установили свойство width к любому из них, содержимое внутри элемента <footer>располагалось между двумя обтекаемыми элементами выше него, заполняя всё доступное пространство. Следовательно, элемент <footer> находился бы в промежутке между элементами <section> и <aside>, занимая свободное место.

### Демонстрация макета без очистки float

Чтобы предотвратить содержимое от обматывания вокруг обтекаемых элементов, нам нужно сделать очистку floatи вернуть страницу в её обычный поток. Мы рассмотрим как очистить float, а затем взглянем на их содержимое.

#### Очистка float

Очистка float происходит с помощью свойства clear, которое принимает несколько различных значений: наиболее часто используемые значения — left, right и both.

```
div {
  clear: left;
}
```

Значение left очищает левые float, в то время как значение right очищает правые float. Значение both, однако, очистит левые и правые float и часто является наиболее идеальным вариантом.

Возвращаясь к нашему предыдущему примеру, если мы используем свойство clear со значением both для элемента <footer>, то можем очистить float. Важно, что clear применяется к элементу, указанному после обтекаемых элементов, а не раньше, чтобы вернуть страницу в её обычный поток.

```
footer {
  clear: both;
}
```

### Демонстрация макета с очисткой float

#### Содержимое float

Вместо очистки float, ещё одним вариантом является установка содержимого float. Результат получится почти такой же, однако содержимое float действительно гарантирует, что все наши стили будут отображаться надлежащим образом.

Чтобы установить содержимое float, обтекаемые элементы должны находиться внутри родительского элемента, он будет выступать в качестве контейнера, оставляя поток документа полностью обычным за его пределами. В стилях для этого родительского элемента представлен класс group, как показано здесь:

```
.group::before,
.group::after {
  content: "";
  display: table;
}
.group::after {
  clear: both;
}
.group {
  clear: both;
  *zoom: 1;
}
```

Здесь немного что происходит, но, по сути, всё что CSS делает — очищает все обтекаемые элементы внутри элемента с классом group и возвращает документ в обычный поток.

Более конкретно, псевдоэлементы ::before и ::after, как указано в уроке 4, динамически генерируют элементы выше и ниже элемента с классом group. Эти элементы не включают в себя какой-либо контент и отображаются как табличные элементы, подобно элементам блочным. Динамически генерируемый элемент после элемента с классом group очищает float внутри элемента с классом group, так же, как и clear ранее. И, наконец, элемент с классом group также очищает все float, которые могут появиться до него на случай, если существует float со значением left или right. Также сюда включена небольшая хитрость, которая заставляет старые браузеры играть красиво.

Здесь больше кода, чем единственная команда clear: both, но он может оказаться весьма полезным.

Рассматривая наш макет страницы с двумя колонками мы могли бы обернуть <section> и <aside> родительским элементом. Этот родительский элемент будет содержать в себе обтекаемые элементы. Код будет выглядеть следующим образом:

HTML

```
<header>...</header>
<div class="group">
  <section>...</section>
  <aside>...</aside>
</div>
<footer>...</footer>
```

CSS

```
.group::before,
.group::after {
  content: "";
  display: table;
}
.group::after {
  clear: both;
}
.group {
  clear: both;
  *zoom: 1;
}
section {
  float: left;
  margin: 0 1.5%;
  width: 63%;
}
aside {
  float: right;
  margin: 0 1.5%;
  width: 30%;
}
```

### Демонстрация макета с содержимым float

Показанная здесь техника известна как «clearfix» и часто встречается на других сайтах с именем класса clearfix или cf. Мы решили использовать имя класса group, потому что он представляет группу элементов и лучше выражает содержимое.

Когда для элементов задано float важно следить за тем, как они влияют на поток страницы и убедитесь, что поток страницы сбрасывается путём очистки или через содержимое float, как надо. В противном случае, отслеживание float может вызвать немало головной боли, особенно на страницах, содержащих несколько строк, в каждой из которых несколько колонок.

## На практике

Вернёмся к сайту Styles Conference и опробуем на нём добавление float к некоторому содержимому.

1. Перво-наперво, перед применением

    

   float

    

   к любому элементу, давайте обеспечим содержимым эти обтекаемые элементы, добавив clearfix в наш CSS. В файле main.css, чуть ниже наших стилей сетки, добавим clearfix под именем класса

    

   group

   , как и раньше.

   ```
   /*
     ========================================
     Clearfix
     ========================================
   */
   .group::before,
   .group::after {
     content: "";
     display: table;
   }
   .group::after {
     clear: both;
   }
   .group {
     clear: both;
     *zoom: 1;
   }
   ```

2. Теперь, когда мы можем использовать float, давайте зададим его для основного <h1> внутри элемента <header> как left и позволим остальному содержимому в заголовке обтекать его справа.

   Чтобы сделать это, добавим класс logo к элементу <h1>. Затем внутри нашего CSS добавим новый раздел стилей для основного заголовка. В этом разделе мы выберем элемент <h1> с классом logo и установим floatкак left.

   HTML

   ```
   <h1 class="logo">
     <a href="index.html">Styles Conference</a>
   </h1>
   ```

   CSS

   ```
   /*
     ========================================
     Основной заголовок
     ========================================
   */

   .logo {
     float: left;
   }
   ```

3. Пока мы здесь, добавим чуть больше деталей к нашему логотипу. Начнём с размещения элемента <br> или разрыва строки между словами «Styles» и «Conference», чтобы заставить текст нашего логотипа располагаться на двух строках.

   В CSS добавим границу по верху нашего логотипа и небольшой вертикальный padding, чтобы логотип свободно «дышал».

   HTML

   ```
   <h1 class="logo">
     <a href="index.html">Styles <br> Conference</a>
   </h1>
   ```

   CSS

   ```
   .logo {
     border-top: 4px solid #648880;
     padding: 40px 0 22px 0;
     float: left;
   }
   ```

4. Поскольку мы сделали элемент <h1> обтекаемым, то хотим установить содержимое float. Ближайшим родителем для <h1> является элемент <header>, поэтому мы добавим к нему класс group. Это применит к нему стили clearfix, которые мы установили ранее.

   ```
   <header class="container group">
     ...
   </header>
   ```

5. Элемент <header> принимает форму, так что давайте взглянем на элемент <footer>. Подобно тому, что мы сделали с <header>, мы установим float для наших авторских прав как left внутри <small> и пусть все остальные элементы обтекают его справа.

   В отличие от элемента <header>, однако, мы не собираемся применять класс непосредственно к обтекаемому элементу. На этот раз мы собираемся добавить класс к родителю обтекаемого элемента и использовать уникальный селектор CSS, чтобы выбрать элемент, а затем задать ему float.

   Начнём с добавления класса primary-footer к элементу <footer>. Поскольку мы знаем, что у нас будут обтекаемые элементы внутри <footer>, то должны добавить класс group, пока мы здесь.

   ```
   <footer class="primary-footer container group">
     ...
   </footer>
   ```

6. Теперь, когда класс primary-footer установлен для элемента <footer>, мы можем использовать этот класс, чтобы целенаправленно выбрать элемент <small> с помощью CSS. Мы хотим задать ему float как left. Не забудьте создать новый раздел в нашем файле main.css для стиля основного подвала.

   ```
   /*
     ========================================
     Основной подвал
     ========================================
   */

   .primary-footer small {
     float: left;
   }
   ```

   Для проверки — здесь мы выбираем элемент <small>, который должен находиться внутри элемента со значением primary-footer у атрибута class, такой как наш элемент <footer>, к примеру.

7. Наконец, добавим небольшой padding сверху и снизу элемента <footer>, это поможет немного отделить его от остальной части страницы. Мы можем сделать это напрямую с помощью класса primary-footer.

   ```
   .primary-footer {
     padding-bottom: 44px;
     padding-top: 44px;
   }
   ```

С учётом всех этих изменений в элементах <header> и <footer>, мы должны быть уверены, что внесли их на каждой странице, а не только на странице index.html.

![С помощью нескольких float, элементы <header> и <footer> на главной странице Styles Conference работают совместно ](https://webref.ru/assets/images/learn-html-css/practice-5-01.png)

Рис. 5.01. С помощью нескольких float, элементы <header> и <footer> на главной странице Styles Conference работают совместно

## Позиционирование через inline-block

В дополнение к использованию float, ещё один способ, которым мы можем позиционировать контент — это применение свойства display в сочетании со значением inline-block. Метод с inline-block, как мы ещё обсудим, в первую очередь полезен для компоновки страниц или для размещения элементов в линию рядом друг с другом.

Напомним, что значение inline-block для свойства display отображает элементы в линию и позволяет им принимать все свойства блочной модели, включая height, width, padding, border и margin. Применение inline-blockпозволяет нам в полной мере воспользоваться блочной моделью, не беспокоясь об очистке каких-либо float.

### inline-block на практике

Давайте взглянем на наш трёхколоночный пример с самого начала. Начнём мы, сохраняя наш HTML таким:

```
<header>...</header>
<section>...</section>
<section>...</section>
<section>...</section>
<footer>...</footer>
```

Теперь вместо float для наших трёх элементов <section> мы изменим у них значение display на inline-block, оставляя свойства margin и width те, что были ранее. В результате наш CSS будет выглядеть следующим образом:

```
section {
  display: inline-block;
  margin: 0 1.5%;
  width: 30%;
}
```

К сожалению, одного этого кода недостаточно чтобы сделать трюк и последний элемент <section> выталкивается на новую строку. Помните, поскольку строчно-блочные элементы отображаются на одной линии друг за другом, они включают единое пространство между ними. Когда размер каждого отдельного пространства добавляется к ширине и значению горизонтального margin всех элементов в строке, общая ширина становится слишком большой, выталкивая последний элемент <section> на новую строку. Чтобы отобразить все элементы <section> на одной строке, следует удалить пустое пространство между каждым <section>.

### Демонстрация элементов inline-block с пробелом

### Удаление пространства между строчно-блочными элементами

Есть несколько методов, как удалить пространство между строчно-блочными элементами и некоторые из них более сложные, чем другие. Мы собираемся сосредоточиться на двух самых простых методах, каждый из которых происходят внутри HTML.

Первое решение — это поместить каждый новый открывающий тег элемента <section> в той же строке, что и закрывающий тег предыдущего элемента <section>. Вместо использования новой строки для каждого элемента мы в итоге начинаем элементы с той же строки. Наш HTML может выглядеть следующим образом:

```
<header>...</header>
<section>
  ...
  </section><section>
  ...
  </section><section>
  ...
</section>
<footer>...</footer>
```

Написание строчно-блочных элементов таким образом гарантирует, что пространства между такими элементами в HTML не существует. Следовательно, пространство и не появится при отображении страницы.

### Демонстрация элементов inline-block без пробелов

Ещё один метод для удаления пространства между строчно-блочными элементами состоит в открытии комментария HTML непосредственно после закрывающего тега элемента. Затем закройте комментарий непосредственно перед открывающим тегом следующего элемента. Это позволяет строчно-блочным элементам начинаться и завершаться на отдельных строках в HTML и «закомментирует» любое потенциальное пространство между элементами. В результате код будет выглядеть следующим образом:

```
<header>...</header>
<section>
  ...
</section><!--
--><section>
  ...
</section><!--
--><section>
  ...
</section>
<footer>...</footer>
```

Ни один из этих вариантов не является совершенным, но они полезны. Я склоняюсь в пользу применения комментариев для лучшей организации, но какой вариант вы выберете полностью зависит от вас.

## Создание многократно используемых макетов

При создании сайта всегда лучше написать модульные стили, которые могут быть повторно задействованы в других местах, а многократно используемые макеты находятся в верхней части списка повторно применяемого кода. Макеты могут быть созданы с помощью float или строчно-блочных элементов, но что работает лучше и почему?

Вопрос что лучше для структуры страницы — обтекаемые или строчно-блочные элементы открыт для обсуждения. Мой подход заключается в использовании строчно-блочных элементов для создания сетки или макета страницы, а затем задействовать float, когда мне хочется чтобы контент обтекал вокруг данного элемента (для чего float и были предназначены при работе с изображениями). Вообще, я также считаю, что со строчно-блочными элементами легче работать.

Тем не менее, используйте то, что работает лучше для вас. Если с одним подходом вы знакомы лучше чем с другим, тогда задействуйте его.

В настоящее время в работе появились новые спецификации CSS — в частности, свойства flex- и grid-, которые помогут решить, как лучше всего сверстать страницы. Следите за этими методами, когда они начнут всплывать.

## На практике

С твёрдым пониманием многократно используемых макетов, пришло время внедрить один на наш сайт Styles Conference.

1. Для сайта Styles Conference мы создадим трёхколоночный макет используя строчно-блочные элементы. Мы сделаем это так, чтобы получить три колонки одинаковой ширины или две колонки с общей шириной, разделённой между ними как 2/3 для одной и 1/3 для другой.

   Для начала мы создадим классы, определяющие ширину этих колонок. Эти два класса мы назовём col-1-3для одной трети и col-2-3 для двух третей. В разделе «Сетка» нашего файла main.css перейдём вперед и определим эти классы и соответствующую им ширину.

   ```
   .col-1-3 {
     width: 33.33%;
   }
   .col-2-3 {
     width: 66.66%;
   }
   ```

2. Мы хотим чтобы обе колонки отображались как строчно-блочные элементы. Нам также надо убедиться, что вертикальное выравнивание у них задано по верхней части каждой колонки.

   Давайте создадим два новых селектора, которые совместно будут использовать display и vertical-align.

   ```
   .col-1-3,
   .col-2-3 {
     display: inline-block;
     vertical-align: top;
   }
   ```

   Взгляните на CSS снова. Мы создали два селектора класса col-1-3 и col-2-3 разделённых запятой. Запятая в конце первого селектора означает, что за ней следует другой селектор. После второго селектора идёт открывающая фигурная скобка, которая сообщает что начинается описание стиля. С помощью запятой разделяющей селекторы мы можем привязать один стиль к нескольким селекторам одновременно.

3. Мы хотим поместить некоторое пространство между колонок, которое поможет разбить содержимое. Это можно сделать, добавив горизонтальный padding к каждой колонке.

   Это хорошо работает, однако, когда две колонки располагаются рядом друг с другом, ширина пространства между ними будет вдвое больше, чем пространство от внешнего края. Чтобы уравновесить это, мы поместим все наши колонки в сетку и добавим к ней тот же padding.

   Давайте воспользуемся классом grid, чтобы определить нашу сетку, а затем зададим одинаковый горизонтальный padding для классов grid, col-1-3 и col-2-3. С запятыми, снова разделяющих наши селекторы, наш CSS выглядит следующим образом:

   ```
   .grid,
   .col-1-3,
   .col-2-3 {
     padding-left: 15px;
     padding-right: 15px;
   }
   ```

4. Когда мы устанавливаем горизонтальный padding, нам нужно быть осторожными. Помните, в прошлом уроке мы создали контейнер с классом container по центру всего нашего контента на странице с шириной 960 пикселей. В данный момент, если бы мы поставили элемент с классом grid внутрь элемента с классом container, то их горизонтальные padding сложились бы вместе и наши колонки не будут отображаться пропорционально ширине остальной части страницы.

   Мы не хотим чтобы это произошло, так что вместо этого мы должны поделиться некоторыми стилями из правил container с набором правил grid. В частности, мы должны поделиться свойством width (чтобы убедиться, что наша страница остаётся фиксированной на 960 пикселей в ширину) и свойством margin(чтобы выровнять по центру страницы элемент с классом grid).

   Мы осуществим это, разбивая набор старых правил container на следующее:

   ```
   .container,
   .grid {
     margin: 0 auto;
     width: 960px;
   }
   .container {
     padding-left: 30px;
     padding-right: 30px;
   }
   ```

   Теперь любой элемент с классом container или grid будет 960 пикселей в ширину и располагаться по центру страницы. Кроме того, мы сохранили существующий горизонтальный padding для любого элемента с классом container путём перемещения его в новый, отдельный набор правил.

5. Хорошо, всю тяжёлую необходимую часть по настройке сетки завершили. Теперь пришло время для работы с нашим HTML и просмотра, как эти классы действуют.

   Мы начнём с тизеров на главной странице, в файле index.html, выровняв их по трём колонкам. В настоящее время тизеры обёрнуты элементом <section> с классом container. Мы хотим изменить класс container на grid так, чтобы внутри мы могли начать размещение колонок.

   ```
   <section class="grid">
     ...
   </section>
   ```

6. Далее мы хотим добавить класс col-1-3 для каждого элемента <section> внутри <section> с классом grid.

   ```
   <section class="grid">

     <section class="col-1-3">
     ...
     </section>
     
     <section class="col-1-3">
     ...
     </section>
     
     <section class="col-1-3">
     ...
     </section>
     
   </section>
   ```

7. И, наконец, поскольку каждая наша колонка является строчно-блочным элементом, нам следует убедиться что мы удалили пустое пространство между ними. Чтобы сделать это мы воспользуемся комментариями и добавим немного документации к каждому разделу, чтобы лучше организовать свой код.

   ```
   <section class="grid">
     
     <!-- Спикеры -->
     
     <section class="col-1-3">
     ...
     </section><!--
     
     Расписание
     
     --><section class="col-1-3">
     ...
     </section><!--
     
     Место проведения
     
     --><section class="col-1-3">
     ...
     </section>
     
   </section>
   ```

   Для проверки — в строке 3 мы оставили комментарий, идентифицирующий раздел «Спикеры», который за ним следует. В конце строки 7 мы открываем комментарий сразу после закрывающего тега </section>. Внутри этого комментария, в строке 9 мы определяем следующий раздел «Расписание». Затем закрываем комментарий в начале строки 11, сразу перед открывающим тегом <section>. Аналогичная структура комментариев появляется в строках с 13 до 17 между двумя элементами <section>, прямо перед разделом «Место проведения». В целом, мы закомментировали любое потенциальное пустое пространство между колонок, одновременно используя те же комментарии для идентификации наших разделов.

Теперь у нас есть повторно используемая трёхколоночная сетка, которая поддерживает разные расстановки, с использованием ширины колонок как 1/3 и 2/3. Наша главная страница теперь содержит три колонки, разделяя все тизеры.

![Главная страница Styles Conference теперь включает трёхколоночный макет ](https://webref.ru/assets/images/learn-html-css/practice-5-02.png)

Рис. 5.02. Главная страница Styles Conference теперь включает трёхколоночный макет

### Демонстрация и исходный код

Ниже вы можете просмотреть сайт Styles Conference в его нынешнем состоянии, а также скачать исходный код сайта на данный момент.

[Просмотр сайта Styles Conference](https://webref.ru/example/learn-html-css/positioning-content/) или [Скачать исходный код](https://webref.ru/assets/files/positioning-content.zip)

## Уникальное позиционирование элементов

Рано или поздно каждый пожелает точно позиционировать элемент, но float или строчно-блочные элементы не позволяют проделать такой трюк. Обтекаемые элементы, которые удаляют элемент из потока страницы, часто приводят к нежелательным результатам, поскольку окружающие элементы обтекают вокруг элемента с float. Строчно-блочные элементы, если только мы не создаём колонки, могут быть довольно неудобны, когда дело касается правильного положения. Для подобных ситуаций мы можем использовать свойство position в сочетании со свойствами смещения блока.

Свойство position определяет, как элемент позиционируется на странице и будет ли он отображаться в обычном потоке документа. Оно применяется в сочетании со свойствами смещения блока — top, right, bottom и left, которые точно определяют, где элемент будет расположен путём перемещения элемента в разных направлениях.

По умолчанию у каждого элемента значение position установлено как static, это означает, что элемент существует в обычном потоке документа и не принимает какие-либо свойства для его смещения. Значение static наиболее часто переписывается значением relative или absolute, которые мы рассмотрим дальше.

### Относительное позиционирование

Значение relative для свойства position позволяет элементам отображаться в обычном потоке страницы, резервируя место для элемента как предполагалось и не позволяя другим элементам его обтекать. Однако, оно также позволяет модифицировать положение элемента с помощью свойств смещения. К примеру, рассмотрим следующие HTML и CSS:

HTML

```
<div>...</div>
<div class="offset">...</div>
<div>...</div>
```

CSS

```
div {
  height: 100px;
  width: 100px;
}
.offset {
  left: 20px;
  position: relative;
  top: 20px;
}
```

### Демонстрация относительного позиционирования

Здесь для второго элемента <div> с классом offset задано значение position как relative, а также два свойства смещения — left и top. Это сохраняет исходное положение элемента и другим элементам не разрешено двигаться в эту область. Кроме того, свойства смещения перемещают элемент, выталкивая его на 20 пикселей от левого и на 20 пикселей от верхнего исходного местоположения.

Для относительно позиционированных элементов важно знать, что свойства смещения блока определяют, куда элемент будет перемещён, учитывая его исходное положение. Таким образом, свойство left со значением 20 пикселей фактически толкает элемент вправо на 20 пикселей. Свойство top со значением 20 пикселей затем будет толкать элемент вниз на 20 пикселей.

Когда мы позиционируем элемент с помощью свойств смещения, элемент перекрывает элемент под ним, а не сдвигает его вниз, как это делают свойства margin или padding.

### Абсолютное позиционирование

Значение absolute для свойства position отличается от значения relative тем, что элемент с абсолютным позиционированием не появляется в обычном потоке документа, исходное пространство и положение абсолютно позиционируемого элемента не резервируется.

Кроме того, абсолютно позиционируемые элементы перемещаются относительно их ближайшего относительно позиционированного родительского элемента. Если относительно позиционированного родителя не существует, то абсолютно позиционированный элемент будет позиционироваться относительно элемента <body>. Это небольшая часть информации; давайте взглянем на то, как это работает внутри некоторого кода:

HTML

```
<section>
  <div class="offset">...</div>
</section>
```

CSS

```
section {
  position: relative;
}
div {
  position: absolute;
  right: 20px;
  top: 20px;
}
```

### Демонстрация абсолютного позиционирования

В этом примере элемент <section> позиционируется относительно, но не включает каких-либо свойств смещения. Следовательно, его положение не меняется. Элемент <div> с классом offset включает значение position как absolute. Поскольку элемент <section> является ближайшим относительно позиционированным родительским элементом для <div>, то элемент <div> будет позиционироваться относительно элемента <section>.

Для относительно позиционированных элементов свойства смещения определяют, в каком направлении элемент будет перемещён относительного самого себя. Для абсолютно позиционируемых элементов свойства смещения определяют, в каком направлении элемент будет перемещён относительно его ближайшего относительно позиционированного родителя.

В результате свойств right и top, элемент <div> появится в 20 пикселях справа и 20 пикселях сверху внутри <section>.

Поскольку элемент <div> позиционируются абсолютно, он не располагается в обычном потоке страницы и будет перекрывать любые окружающие его элементы. Кроме того, исходное положение <div> не сохраняется и другие элементы могут занять это место. Как правило, большая часть позиционирования может происходить без применения свойств position и свойств смещения, но в некоторых случаях они могут оказаться чрезвычайно полезны.

## Резюме

Изучение позиционирования содержимого в HTML и CSS является огромным шагом в сторону освоения этих языков. Добавьте к этому блочную модель и вот мы уверенно движемся по пути превращения во фронтенд-разработчиков.

Для проверки, в этом уроке мы рассмотрели следующее:

- Что такое float и как его использовать, чтобы позиционировать содержимое.
- Как очистить и установить содержимое обтекаемых элементов.
- Как позиционировать содержимое с помощью строчно-блочных элементов.
- Как удалить пустое пространство между строчно-блочными элементами.
- Как уникально позиционировать контент через относительное и абсолютное позиционирование элементов.

Мы добавляем новые навыки с каждым уроком, так что давайте продолжим. Следующая тема — типографика!







